import Mathlib.LinearAlgebra.Matrix.Determinant.Basic
import Mathlib.LinearAlgebra.Eigenspace.Minpoly
import Mathlib.LinearAlgebra.Charpoly.Basic

import MIL.Common

-- K is a field
-- V is a K-vector space
variable {K : Type*} [Field K] {V : Type*} [AddCommGroup V] [Module K V]

-- U is a K-linear subspace of V
--   U is a subset of V
--   U contains 0
--   U is closed under addition and scalar mul
-- Subspaces in Lean are represented as bundled structures `Submodule K V`
--   store the proofs of closure properties
--   coercion to `Set V` (can act as a set, proving equality with `ext`, etc.)

-- Subspace is closed under addition
example (U : Submodule K V) {x y : V} (hx : x âˆˆ U) (hy : y âˆˆ U) :
    x + y âˆˆ U :=
  U.add_mem hx hy

-- Subspace is closed under scalar mul
example (U : Submodule K V) {x : V} (hx : x âˆˆ U) (a : K) :
    a â€¢ x âˆˆ U :=
  U.smul_mem a hx

-- â„ is a subspace of â„‚ (a vector space over â„)
noncomputable example : Submodule â„ â„‚ where
  -- Image of the coercion (â†‘) from â„ to â„‚:
  --   set of all complex numbers obtained from a real number
  carrier := Set.range ((â†‘) : â„ â†’ â„‚)
  -- Proof of closure of addition
  add_mem' := by
    rintro _ _ âŸ¨n, rflâŸ© âŸ¨m, rflâŸ©
    use n + m
    simp
  -- Proof of 0 being in the subspace
  zero_mem' := by
    use 0
    simp
  -- Proof of closure of scalar mul
  smul_mem' := by
    rintro c - âŸ¨a, rflâŸ©
    use c*a
    simp

-- Give
--   Ï†: K-linear map from V to W
--   H: subspace of W
-- then Ï†â»Â¹(H) is a subspace of V
def preimage {W : Type*} [AddCommGroup W] [Module K W] (Ï† : V â†’â‚—[K] W) (H : Submodule K W) :
    Submodule K V where
  carrier := Ï† â»Â¹' H
  zero_mem' := by
    dsimp
    rw [Set.mem_preimage]
    rw [Ï†.map_zero]
    exact H.zero_mem
  add_mem' := by
    intro a b ha hb
    rw [Set.mem_preimage] at *
    rw [Ï†.map_add]
    exact H.add_mem ha hb
  smul_mem' := by
    dsimp
    intro c x hx
    rw [Set.mem_preimage] at *
    rw [Ï†.map_smul]
    exact H.smul_mem c hx

-- Subspace is a vector space
-- and Lean can automatically infer this.
example (U : Submodule K V) : Module K U := inferInstance

-- Here, `U` is not a type (`Type*`) but has type `Submodule K V`.
-- Lean automatically coerces U to the subtype `{x : V // x âˆˆ U}`
example (U : Submodule K V) : Module K {x : V // x âˆˆ U} := inferInstance

-- Set of all subspaces of V (submodules): complete lattice
--   partial order: inclusion
--   infimum (meet): intersection
--   supremum (join): sum
-- (complete: any collection, not just finite ones, has an inf and a sup)

-- The infimum of two subspaces H and H' of V is
--   a subspace of V
--   intersection of the carrier of H and the carrier of H'
example (H H' : Submodule K V) :
    ((H âŠ“ H' : Submodule K V) : Set V) = (H : Set V) âˆ© (H' : Set V) := rfl

-- The supremum of two subspaces H and H' of V is
--   a subspace of V
--   smallest subspace containing the union (i.e., sum) of the two subspaces
-- `Submodule.span M s`: smallest submodule of M containing s
--                       called the submodule generated by s
-- In Lean, `H âŠ” H' = H + H'` by definition.
example (H H' : Submodule K V) :
    ((H âŠ” H' : Submodule K V) : Set V) = Submodule.span K ((H : Set V) âˆª (H' : Set V)) := by
  simp [Submodule.span_union]

-- V is a subspace of itself.
-- But, `V` is a type, sot it cannot be of type `Submodule K V`.

-- V is the top element in the lattice of subspaces.
example (x : V) : x âˆˆ (âŠ¤ : Submodule K V) := trivial

-- The zero subspace {0} is the bottom element.
example (x : V) : x âˆˆ (âŠ¥ : Submodule K V) â†” x = 0 := Submodule.mem_bot K

-- `IsCompl U V`: U and V are "complements" of each other
--                in the lattice of submodules.
-- "Complement" is general for any bounded partially ordered type.
-- "In internal direct sum" is specific for subspaces.

-- If two subspaces are in direct sum then they span the whole space.
example (U V : Submodule K V) (h : IsCompl U V) :
  U âŠ” V = âŠ¤ := h.sup_eq_top

-- If two subspaces are in direct sum then they intersect only at zero.
example (U V : Submodule K V) (h : IsCompl U V) :
  U âŠ“ V = âŠ¥ := h.inf_eq_bot

section
open DirectSum

-- Consider an index set Î¹ with decidable equality.
variable {Î¹ : Type*} [DecidableEq Î¹]

-- The following examples deal with a family of subspaces {Uáµ¢ : i âˆˆ Î¹} of V.
-- `DirectSum.IsInternal U`: The family is in internal direct sum.

-- If subspaces are in internal direct sum then they span the whole space.
example (U : Î¹ â†’ Submodule K V) (h : DirectSum.IsInternal U) :
  â¨† i, U i = âŠ¤ := h.submodule_iSup_eq_top

-- If subspaces are in internal direct sum then they pairwise intersect only at zero.
-- `.submodule_independent`: if the direct sum of the submodules is internal
--                           then the submodules are independent.
-- `.pairwiseDisjoint`: if the submodules are independent
--                      then the submodules are pairwise disjoint.
-- `.eq_bot`: if the submodules are pairwise disjoint
--            then the infimum of two different submodules is the bottom elem.
example {Î¹ : Type*} [DecidableEq Î¹] (U : Î¹ â†’ Submodule K V) (h : DirectSum.IsInternal U)
    {i j : Î¹} (hij : i â‰  j) : U i âŠ“ U j = âŠ¥ :=
  (h.submodule_independent.pairwiseDisjoint hij).eq_bot

-- The direct sum is internal iff
--   the sum is the whole space
--   the pairwise intersection is the bottom element
#check DirectSum.isInternal_submodule_iff_independent_and_iSup_eq_top

-- `â¨ i, U i`: external direct sum
-- Internal direct sum: decompose an existing space
--   Start with vector space V
--   A collection of subspaces {Uáµ¢} within V
--   V is the indirect sum of {Uáµ¢} if every vector in V can be
--   written uniquely as a finite sum of vectors from each of {Uáµ¢}.
-- External direct sum: build a new space from existing ones
--   Start with a collection of independent vector spaces {Uáµ¢}
--   Construct a new vector space â¨áµ¢ Uáµ¢
--     each elem is a tuple of vectors from each of {Uáµ¢},
--     only finitely many of them are non-zero.

-- `coeLinearMap U`: canonical linear map from the external direct sum to V
--   map a tuple of vectors (in the external direct sum)
--   to their sum (as vectors in V)

-- If {Uáµ¢ : i âˆˆ Î¹} is in internal direct sum
-- then the canonical linear map is bijective.
-- Proof: By definition, each v âˆˆ V can be uniquely written as a sum.
--   1) Since the sum is unique, âˆ‘áµ¢ uáµ¢ = 0 â‡’ âˆ€ i, uáµ¢ = 0
--      So the kernal is {0} and thus the map is injective.
--   2) Surjectivity is obvious from the definition.
-- Therefore, the external direct sum are linearly isomorphic to V.
noncomputable example {Î¹ : Type*} [DecidableEq Î¹] (U : Î¹ â†’ Submodule K V)
    (h : DirectSum.IsInternal U) : (â¨ i, U i) â‰ƒâ‚—[K] V :=
  LinearEquiv.ofBijective (coeLinearMap U) h
end

-- Given set s
-- `Submodule.span K s`: smallest submodule of K containing s
--                       called the submodule generated by s
-- Common: all linear combinations of vectors of s.
-- Often more efficient: universal property with `.span_le`
-- `.span_le`: span of s â‰¤ submodule E iff s âŠ† E (as set)
example {s : Set V} (E : Submodule K V) : Submodule.span K s â‰¤ E â†” s âŠ† E :=
  Submodule.span_le

-- Ex: span(Sâ‚ âˆª Sâ‚‚) = span(Sâ‚) âŠ” span(Sâ‚‚)
-- Proof:
-- (â‰¤) Only need to show Sâ‚ âˆª Sâ‚‚ âŠ† span(Sâ‚) âŠ” span(Sâ‚‚)
-- (â‰¥) Sâ‚ âŠ† Sâ‚ âˆª Sâ‚‚ â‡’ span(Sâ‚) â‰¤ span(Sâ‚ âˆª Sâ‚‚)

-- Galois connection: pair of functions l : A â†’ B, u : B â†’ A
--                    where (A, â‰¤[A]) and (B, â‰¤[B]) are posets
--   âˆ€ a âˆˆ A, b âˆˆ B, l(a) â‰¤[B] b â†” a â‰¤[A] u(b)
-- l and u are adjoint functors, l/u: lower/upper adjoint
-- Ex: A = â„, B = â„¤, l(a) = âŒˆaâŒ‰, u(b) = b
-- Ex: A = ğ’«(X), B = all closed subset of X
--     l: ğ’«(X) â†’ B, S â†¦ closure(S) (smallest closed set containing S)
--     u: B â†’ ğ’«(X), S â†¦ S (as a subset of X)
--     l(S) â‰¤[B] S' â†” l(S) âŠ† S' â†” S âŠ† S' â†” S â‰¤[A] u(S')

-- Galois insertion: Galois connection where l âˆ˜ u = id (i.e., l(u(b)) = b)
-- Ex: (continue) l(u(S)) = l(S) = S (since S âˆˆ B is closed)

-- l = `.span K`: map set to subspace
-- u = `(â†‘) : Submodule K V â†’ Set V`: map subspace to set (coercion)
-- `.gi K V`: proof that l and u form a Galois insertion
example : GaloisInsertion (Submodule.span K) ((â†‘) : Submodule K V â†’ Set V) :=
  Submodule.gi K V

example {S T : Submodule K V} {x : V} (h : x âˆˆ S âŠ” T) :
    âˆƒ s âˆˆ S, âˆƒ t âˆˆ T, x = s + t  := by
  rw [â† S.span_eq, â† T.span_eq, â† Submodule.span_union] at h
  -- `h : x âˆˆ Submodule.span K (â†‘S âˆª â†‘T)` (x âˆˆ span(S âˆª T))
  -- allows proof by induction using `.span_induction`
  induction h using Submodule.span_induction with
  -- Base case: x = 0
  | zero =>
      use 0, S.zero_mem
      use 0, T.zero_mem
      rw [zero_add]
  -- Base case: x âˆˆ S âˆª T
  | mem x h =>
      rcases h with (hS | hT)
      Â· use x, hS
        use 0, T.zero_mem
        rw [add_zero]
      Â· use 0, S.zero_mem
        use x, hT
        rw [zero_add]
  -- Inductive step: x â† x + y
  | add x y hx hy hx' hy' =>
      rcases hx' with âŸ¨sx, hsx, tx, htx, rflâŸ©
      rcases hy' with âŸ¨sy, hsy, ty, hty, rflâŸ©
      use sx + sy, S.add_mem hsx hsy
      use tx + ty, T.add_mem htx hty
      rw [add_add_add_comm]
  -- Inductive step: x â† a â€¢ x
  | smul a x hx hx' =>
      rcases hx' with âŸ¨s, hs, t, ht, rflâŸ©
      use a â€¢ s, S.smul_mem a hs
      use a â€¢ t, T.smul_mem a ht
      rw [DistribMulAction.smul_add]

section

-- Let W be a K-vector space.
-- Let Ï† be a linear map from V to W.
variable {W : Type*} [AddCommGroup W] [Module K W] (Ï† : V â†’â‚—[K] W)

-- Let E be a subspace of V.
-- Image of E under Ï†, Ï†(E), is a subspace of W.
-- `.map Ï† E` or `E.map Ï†` pushes E from V to W.
variable (E : Submodule K V) in
#check (Submodule.map Ï† E : Submodule K W)

-- Let F be a subspace of W.
-- Preimage of F under Ï†, Ï†â»Â¹(F), is a subspace of V.
-- `.comap Ï† F` or `F.comap Ï†` pulls F from W to V.
variable (F : Submodule K W) in
#check (Submodule.comap Ï† F : Submodule K V)

-- Range of Ï† is the image of V
-- We cannot use `Ï†.range/ker` is not limited to linear maps.
-- However, since `LinearMap.range/ker Ï†` has type `Submodule K V`
-- so `.map Ï† âŠ¤` works because `Submodule.map` can be inferred.
example : LinearMap.range Ï† = .map Ï† âŠ¤ := LinearMap.range_eq_map Ï†

-- Kernel of Ï† is (definitionally) the preimage of the zero subspace
example : LinearMap.ker Ï† = .comap Ï† âŠ¥ := rfl -- Submodule.comap_bot Ï†

open Function LinearMap

-- Ï† is injective iff its kernal is the bottom element (zero subspace).
example : Injective Ï† â†” ker Ï† = âŠ¥ := ker_eq_bot.symm

-- Ï† is surjective iff its range is the top element (entire space).
example : Surjective Ï† â†” range Ï† = âŠ¤ := range_eq_top.symm

-- x âˆˆ E â†’ Ï†(x) âˆˆ Ï†(E)
#check Submodule.mem_map_of_mem
-- y âˆˆ Ï†(E) â†” âˆƒ x âˆˆ E, y = Ï†(x)
#check Submodule.mem_map
-- x âˆˆ Ï†â»Â¹(F) â†” Ï†(x) âˆˆ F
#check Submodule.mem_comap

example (E : Submodule K V) (F : Submodule K W) :
    Submodule.map Ï† E â‰¤ F â†” E â‰¤ Submodule.comap Ï† F := by
  constructor
  Â· -- Suppose Ï†(E) â‰¤ F.
    -- Let x âˆˆ E.
    intro hÏ†EleF _ hxE
    -- Then Ï†(x) âˆˆ Ï†(E).
    -- Then Ï†(x) âˆˆ F or x âˆˆ Ï†â»Â¹(F).
    exact hÏ†EleF (Submodule.mem_map_of_mem hxE)
  Â· -- Suppose E â‰¤ Ï†â»Â¹(F).
    -- Let y âˆˆ Ï†(E).
    intro hEleÏ†invF _ hyÏ†E
    -- Then, âˆƒ x âˆˆ E, Ï†(x) = y.
    rcases hyÏ†E with âŸ¨_, hxE, rflâŸ©
    -- Then, x âˆˆ Ï†â»Â¹(F) so y = Ï†(x) âˆˆ F.
    exact hEleÏ†invF hxE

-- Let E be a subspace of V.
variable (E : Submodule K V)

-- The quotient vector space is a K-vector space
-- whose elements are equiv classes of vectors in V
--   u and v are equivalent if u - v âˆˆ E
--   denoted [v] or v + E
example : Module K (V â§¸ E) := inferInstance

-- `E.mkQ`: Canonical projection map
--   V â†’ V â§¸ E
--   v â†¦ v + E
example : V â†’â‚—[K] V â§¸ E := E.mkQ

-- The kernel of the canonical projection map is the subspace.
example : ker E.mkQ = E := E.ker_mkQ

-- The range of the canonical projection map is the entire space.
-- Thus, the canonical projection map is surjective.
example : range E.mkQ = âŠ¤ := E.range_mkQ

-- Universal property
-- Recall: Ï† is a linear map from V to W
-- `hÏ†`: E is contained in the kernel of Ï†
-- `E.liftQ Ï† hÏ†`: linear map from V â§¸ E to W
-- Ï†E(v + E) = Ï†(v)
-- Ï†E is well-defined with `hÏ†`
--   For v, v' âˆˆ v + E or v - v' âˆˆ E â‡’ v - v' âˆˆ ker(Ï†)
--   Ï†E(v + E) = Ï†(v) = Ï†(v - v' + v')
--                    = Ï†(v - v') + Ï†(v')
--                    = 0 + Ï†(v') = Ï†(v') = Ï†E(v' + E)
example (hÏ† : E â‰¤ ker Ï†) : V â§¸ E â†’â‚—[K] W := E.liftQ Ï† hÏ†

-- Given
--   subspace F of W
--   E â‰¤ Ï†â»Â¹(F)
-- `E.mapQ F Ï† hÏ†`: linear map from V â§¸ E to W â§¸ F
-- Ï†EF(v + E) = Ï†(v) + F
-- Ï†EF is well-defined with `hÏ†`
--   Since E â‰¤ Ï†â»Â¹(F), Ï†(E) â‰¤ F. (Galois connection)
--   Let v, v' âˆˆ v + E.
--   Then, v - v' âˆˆ E.
--   Then, Ï†(v - v') âˆˆ Ï†(E).
--   Then, Ï†(v) - Ï†(v') âˆˆ F.
--   So Ï†EF(v + E) = Ï†(v) + F = Ï†(v') + F = Ï†EF(v' + E).
example (F : Submodule K W) (hÏ† : E â‰¤ .comap Ï† F) : V â§¸ E â†’â‚—[K] W â§¸ F := E.mapQ F Ï† hÏ†

-- First isomorphism theorem: V â§¸ ker(Ï†) is isomorphic to im(Ï†)
--   ker(Ï†) is a subspace of V
--   use the universal property => linear map from V â§¸ ker(Ï†) to W
--   restrict it to linear map Ï†' from V â§¸ ker(Ï†) to im(Ï†)
--   prove Ï†' is injective
--     Let v, v' s.t Ï†'(v + ker(Ï†)) = Ï†'(v' + ker(Ï†)).
--     Then, Ï†(v) = Ï†(v') or Ï†(v - v') = 0 or v - v' âˆˆ ker(Ï†).
--     Thus, v + ker(Ï†) = v' + ker(Ï†).
--   prove Ï†' is surjective (obvious)
noncomputable example : (V â§¸ LinearMap.ker Ï†) â‰ƒâ‚—[K] range Ï† := Ï†.quotKerEquivRange

open Submodule

-- Ï†(Ï†â»Â¹(F)) = im(Ï†) âŠ“ F
#check Submodule.map_comap_eq
-- Ï†â»Â¹(Ï†(E)) = E âŠ” ker(Ï†)
#check Submodule.comap_map_eq

-- Each subspace in V / E corresponds to a subspace of V that contains E
-- `Submodule K (V â§¸ E)`: set of subspaces in V â§¸ E
-- `{ F : Submodule K V // E â‰¤ F }`: set of subspaces of V that contains E
--
-- Quotienting out E creates a new space where
--    E is "squashed" to the "zero vector"/"0"
--    any subspace containing E has a "squashed" version
--    any subspace not containing E won't have its "squashed" version having "0"
--
-- Ex: V = â„Â³, E = {(x, 0, 0) : x âˆˆ â„} (x-axis)
--     V â§¸ E = {[y, z] : y, z âˆˆ â„} where [y, z] = {(x, y, z) : x âˆˆ â„}
--     the "0" in quotient space (V â§¸ E) is the x-axis in V
--     each "point" [y, z] in V â§¸ E is a line through (0, y, z) parallel to the x-axis
--     each subspace in V â§¸ E ("line" passing through "0")
--     corresponds to a subspace of V containing E = plane containing x-axis in V
example : Submodule K (V â§¸ E) â‰ƒ { F : Submodule K V // E â‰¤ F } where
  toFun L := âŸ¨
    -- `E.mkQ`: canonical map Ï† from V to V â§¸ E
    -- `.comap E.mkQ`: pull-back function L â†¦ Ï†â»Â¹(L)
    -- `.comap E.mkQ L`: for a subspace L of V â§¸ E, pull S back to a subspace in V
    -- Ex: pull back a line in V â§¸ E to a plane in V
    .comap E.mkQ L,
    -- Prove: E â‰¤ `.comap E.mkQ L`
    --   E = ker(Ï†) (E is "squashed" to "0" so E is the kernel of Ï†)
    --     = Ï†â»Â¹(âŠ¥) (kernel of Ï† contains elements that Ï† maps to âŠ¥)
    --     â‰¤ Ï†â»Â¹(L) (âŠ¥ â‰¤ L)
    calc
      E = ker E.mkQ := by rw [E.ker_mkQ]
      _ = .comap E.mkQ âŠ¥ := by rw [comap_bot]
      _ â‰¤ .comap E.mkQ L := fun _ h => (OrderBot.bot_le L) h
  âŸ©
  invFun R := map E.mkQ R
  left_inv := by
    -- Prove: `invFun` is the left inverse of `toFun`
    rw [leftInverse_iff_comp]
    -- Prove: `invFun` âˆ˜ `toFun` = id
    -- Prove: âˆ€ subspace L of V â§¸ E, âˆ€ x âˆˆ V â§¸ E
    --        x âˆˆ Ï†(Ï†â»Â¹(L)) â†” x âˆˆ L
    -- Fix a subspace L of V â§¸ E and x âˆˆ V â§¸ E
    ext L x
    dsimp
    -- Ï†(Ï†â»Â¹(L)) = im(Ï†) âŠ“ L = âŠ¤ âŠ“ L = L
    have := calc
      map E.mkQ (comap E.mkQ L) = range E.mkQ âŠ“ L := by rw [map_comap_eq]
      _ = âŠ¤ âŠ“ L := by rw [E.range_mkQ]
      _ = L := by rw [top_inf_eq]
    rw [this]
  right_inv := by
    -- Prove: `invFun` is the right inverse of `toFun`
    rw [rightInverse_iff_comp]
    -- Prove: `toFun` âˆ˜ `invFun` = id
    -- Prove: âˆ€ R â‰¤ E, x âˆˆ V
    --        x âˆˆ Ï†â»Â¹(Ï†(R)) â†” x âˆˆ R
    ext R x
    dsimp
    -- Ï†â»Â¹(Ï†(L)) = L âŠ” ker(Ï†) = L âŠ” E = L (E â‰¤ L)
    have := calc
      comap E.mkQ (map E.mkQ â†‘R) = â†‘R âŠ” ker E.mkQ := by rw [comap_map_eq]
      _ = â†‘R âŠ” E := by rw [E.ker_mkQ]
      _ = â†‘R := sup_eq_left.mpr R.2
    rw [this]
