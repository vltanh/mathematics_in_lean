import MIL.Common
import Mathlib.Topology.Instances.Real

open Set Filter Topology

/-
Filter F on a set X: collection of subsets of X s.t.
  contains the universe: X ∈ F
    `F.univ_sets : univ ∈ F.sets`
  upward closed: if U ∈ F and U ⊆ V then V ∈ F
    `F.sets_of_superset : ∀ {U V}, U ∈ F.sets → U ⊆ V → V ∈ F.sets`
  closed under finite intersections: if U, v ∈ F then U ∩ V ∈ F
    `F.inter_sets : ∀ {U, V}, U ∈ F.sets → V ∈ F.sets → U ∩ V ∈ F.sets`

Intuition: F contains "large" or "significant" subsets of X

Examples:
  `atTop : Filter ℕ`: "tails" of natural numbers
    containing sets of the form {n ∈ N | n ≥ N} where N ∈ ℕ
    ex: {3, 4, 5, ...} ∈ `atTop`
  `𝓝 x`: neighborhood filter of a point x in a topological space
    containing neighborhoods of x
    ex: (6 - ε, 6 + ε) ∈ `𝓝 6`, ∀ ε > 0

In Lean/Mathlib:
  `F` is implemented as a structure bundling
    `F.sets : Set (Set X)`: collection of sets
    `F.univ_sets`, `F.sets_of_superset`, `F.inter_sets`: filter axioms
  `(U ∈ F) = (U ∈ F.sets)`: simplifying notation
-/

-- Principal filter of a set s (generated by s)
--   contains sets that contain s {t | s ⊆ t}
--   denoted 𝓟 s
def principal {α : Type*} (s : Set α) : Filter α
    where
  sets := { t | s ⊆ t }
  univ_sets :=
    -- The universe set X is the superset of all sets, including s.
    -- Therefore, the principal filter contains the universe set.
    subset_univ s
  sets_of_superset :=
    -- Let t be a subset of X.
    -- Suppose t ∈ 𝓟 s. Then, s ⊆ t.
    -- If t ⊆ u then s ⊆ u. Thus, u ∈ 𝓟 s.
    Subset.trans
  inter_sets :=
    -- Let t, u be subsets of X.
    -- Suppose t, u ∈ 𝓟 s. Then, s ⊆ t and s ⊆ u.
    -- Then, s ⊆ t ∩ u. Thus, t ∩ u ∈ 𝓟 s.
    subset_inter

-- `atTop`/"tails" filter on ℕ (or any type with a preorder)
example : Filter ℕ :=
  { sets := { s | ∃ a, ∀ b, a ≤ b → b ∈ s }
    univ_sets := by
      -- We need to show that ∃ a ∈ ℕ, ∀ b ∈ ℕ, a ≤ b → b ∈ univ.
      -- Let a = 0.
      use 0
      -- Let b ∈ ℕ and b ≥ 0 (= a).
      intro _ _
      -- Then b ∈ ℕ (= univ).
      trivial
    sets_of_superset := by
      -- Let x ⊆ y ⊆ ℕ.
      -- Let x ∈ `atTop` with lower bound a.
      -- We need to show that y ∈ `atTop`,
      -- i.e., ∃ a' ∈ ℕ, ∀ b ∈ ℕ, a' ≤ b → b ∈ y.
      intro x y ⟨a, ha⟩ hxy
      -- Let a' = a.
      use a
      -- Let b ∈ ℕ and b ≥ a'.
      intro b hb
      -- Then, b ≥ a (∵ a = a'). So, b ∈ x.
      -- Since x ⊆ y, b ∈ y.
      exact hxy (ha b hb)
    inter_sets := by
      -- Let x, y ∈ `atTop` with lower bounds ax, ay.
      -- We need to show that x ∩ y ∈ `atTop`,
      -- i.e., ∃ a ∈ ℕ, ∀ b ∈ ℕ, a ≤ b → b ∈ x ∩ y.
      intro x y ⟨ax, hx⟩ ⟨ay, hy⟩
      -- Let a = max(ax, ay).
      use max ax ay
      -- Let b ∈ ℕ and b ≥ a.
      intro b hb
      -- We need to show b ∈ x and b ∈ y.
      constructor
      · -- Since b ≥ a = max(ax, ay) ≥ ax, b ∈ x.
        exact hx b (le_of_max_le_left hb)
      · -- Similarly, b ∈ y.
        exact hy b (le_of_max_le_right hb)
  }

-- Neighborhood filter of a x₀
--   containing neighborhoods of x₀
--     neighborhood of x₀: set containing an open interval (x₀ - ε, x₀ + ε)
--   denoted 𝓝 x₀
example (x₀ : ℝ) : Filter ℝ where
  sets := { s | ∃ ε > 0, Ioo (x₀ - ε) (x₀ + ε) ⊆ s }
  univ_sets := by
    -- Show: ∃ ε > 0, (x₀ - ε, x₀ + ε) ⊆ ℝ
    -- Let ε = 1. Show: 1 > 0 and (x₀ - 1, x₀ + 1) ⊆ ℝ.
    use 1
    constructor
    · -- 1 > 0 is trivial.
      exact Real.zero_lt_one
    · -- If x ∈ (x₀ - 1, x₀ + 1), then x ∈ ℝ trivially.
      intro x _
      trivial
  sets_of_superset := by
    -- Let s ⊆ t ⊆ ℝ.
    -- Let s ∈ 𝓝 x₀ with "radius" ε > 0.
    -- Then, (x₀ - ε, x₀ + ε) ⊆ s.
    -- Show: ∃ ε' > 0, (x₀ - ε', x₀ + ε') ⊆ t.
    rintro s t ⟨ε, ε_pos, hs⟩ hst
    -- Let ε' = ε. Show: ε' > 0 and (x₀ - ε', x₀ + ε') ⊆ t.
    use ε
    constructor
    · -- Then, ε' = ε > 0.
      exact ε_pos
    · -- And, (x₀ - ε', x₀ + ε') = (x₀ - ε, x₀ + ε) ⊆ s ⊆ t.
      exact Subset.trans hs hst
  inter_sets := by
    -- Let s, t ∈ 𝓝 x₀ with "radii" εs, εt > 0.
    -- Then, (x₀ - εs, x₀ + εs) ⊆ s and (x₀ - εt, x₀ + εt) ⊆ t.
    -- Show: ∃ ε > 0, (x₀ - ε, x₀ + ε) ⊆ s ∩ t.
    rintro s t ⟨εs, εs_pos, hs⟩ ⟨εt, εt_pos, ht⟩
    -- Let ε = min(εs, εt).
    -- Show: ε > 0 and (x₀ - ε, x₀ + ε) ⊆ s ∩ t.
    use min εs εt
    constructor
    · -- Since εs, εt > 0, ε = min(εs, εt) > 0.
      exact lt_min εs_pos εt_pos
    · -- Let x ∈ (x₀ - ε, x₀ + ε).
      rintro x ⟨hxl, hxr⟩
      -- Show x ∈ s ∩ t by showing x ∈ s and x ∈ t.
      constructor
      · -- Since (x₀ - εs, x₀ + εs) ⊆ s, show x ∈ (x₀ - εs, x₀ + εs).
        apply hs
        -- Show x₀ - εs < x and x < x₀ + εs.
        constructor
        · -- x₀ - εs ≤ x₀ - min(εs, εt) = x₀ - ε < x.
          calc
            x₀ - εs ≤ x₀ - min εs εt := tsub_le_tsub_left (min_le_left εs εt) x₀
            _ < x := hxl
        · -- x < x₀ + min(εs, εt) ≤ x₀ + εs
          calc
            x < x₀ + min εs εt := hxr
            _ ≤ x₀ + εs := add_le_add_left (min_le_left εs εt) x₀
      · -- Since (x₀ - εs, x₀ + εs) ⊆ s, show x ∈ (x₀ - εs, x₀ + εs).
        apply ht
        -- Show x₀ - εs < x and x < x₀ + εs.
        constructor
        · -- x₀ - εs ≤ x₀ - min(εs, εt) = x₀ - ε < x.
          calc
            x₀ - εt ≤ x₀ - min εs εt := tsub_le_tsub_left (min_le_right εs εt) x₀
            _ < x := hxl
        · -- x < x₀ + min(εs, εt) ≤ x₀ + εs
          calc
            x < x₀ + min εs εt := hxr
            _ ≤ x₀ + εt := add_le_add_left (min_le_right εs εt) x₀

-- For any V ∈ G (filter on Y), preimage of V under f is in F (filter on X).
-- Intuition: as x "approaches" a value/concept according to F,
--            f(x) "approaches" a value/concept according to G.
-- Example:
-- 1. X = ℕ, Y = ℝ, F = `atTop`, G = 𝓝 x
--    `Tendsto₁ u atTop (𝓝 x)`: sequence (uₙ) converges to x
--      as n "approaches" infinity (according to `atTop`),
--      uₙ "approaches" x (according to 𝓝 x)
-- 2. X = Y = ℝ, F = 𝓝 x₀, G = 𝓝 y₀
--    `Tendsto₁ f (𝓝 x₀) (𝓝 y₀)`: function f has the limit y₀ as x approaches x₀
def Tendsto₁ {X Y : Type*} (f : X → Y) (F : Filter X) (G : Filter Y) :=
  ∀ V ∈ G, f ⁻¹' V ∈ F

-- `Filter.map f F` is a filter on Y containing V s.t. f⁻¹(V) ∈ F
--   a set V is in the pushed-forward filter iff
--   its preimage under f is in the original filter
example {X Y : Type*} (f : X → Y) (F : Filter X) : Filter Y where
  sets := { V | f ⁻¹' V ∈ F }
  univ_sets :=
    -- The preimage of the universe set under any function is the universe set.
    -- The universe set is a member of the filter F.
    F.univ_mem
  sets_of_superset := by
    -- Let U ⊆ V ⊆ Y.
    -- Suppose U ∈ `map f F`. Show V ∈ `map f F`.
    intro U V hU hUV
    -- Since U ∈ `map f F`, f⁻¹(U) ∈ F.
    -- Since U ⊆ V, f⁻¹(U) ⊆ f⁻¹(V). Thus, f⁻¹(V) ∈ F.
    -- Thus, V ∈ `map f F`.
    apply F.sets_of_superset hU (fun x hxfinvU ↦ hUV hxfinvU)
  inter_sets := by
    -- Let U, V ∈ `map f F`.
    -- Then, f⁻¹(U), f⁻¹(V) ∈ F.
    -- Then, f⁻¹(U ∩ V) = f⁻¹(U) ∩ f⁻¹(V) ∈ F.
    -- Thus, U ∩ V ∈ `map f F`.
    intro U V hU hV
    exact Filter.inter_sets F hU hV

-- IMPORTANT: order relation in filter is the *reverse* inclusion
--   F ≤ G iff G ⊆ F
--   Intuition: sets considered large by G are also considered large by F
--              F has a less strict notion of largeness than G
--   Example: If A ⊆ B ⊆ X, then 𝓟 A ≤ 𝓟 B
--     intuitively, 𝓟 A (resp. 𝓟 B) requires a set to contain A (resp. B) to be "large"
--     since A ⊆ B, 𝓟 A is less strict (since if a set contains B, it also contains A)
example {X : Type*} (A B : Set X) (h: A ⊆ B) : 𝓟 A ≤ 𝓟 B := by
  -- Let U ∈ 𝓟 B.
  intro U hU
  -- Then, B ⊆ U.
  -- Since A ⊆ B, A ⊆ U.
  -- Thus, U ∈ 𝓟 A.
  exact Subset.trans h hU

-- Filters on X = generalized subsets of X
--   any (sub)set s corresponds to a principal filter 𝓟 s
def Tendsto₂ {X Y : Type*} (f : X → Y) (F : Filter X) (G : Filter Y) :=
  map f F ≤ G

-- The two definitions are equivalent.
-- Drawback of `Tendsto₁`: quantifier over all V ∈ G
example {X Y : Type*} (f : X → Y) (F : Filter X) (G : Filter Y) :
    Tendsto₂ f F G ↔ Tendsto₁ f F G :=
  Iff.rfl

-- `Filter.map` is monotone
--   given m : α → β,
--   if (F : Filter α) ≤ (G : Filter α)
--   then (map m F : Filter β) ≤ (map m G : Filter β)
#check (@Filter.map_mono : ∀ {α β} {m : α → β}, Monotone (map m))

-- `Filter.map` is compatible with function composition
--   map (m' ∘ m) F = map m' (map m F)
--   i.e., pushing forward under the composition of functions is the same as
--         pushing forward under the first function and then the second function
#check
  (@Filter.map_map :
    ∀ {α β γ} {f : Filter α} {m : α → β} {m' : β → γ}, map m' (map m f) = map (m' ∘ m) f)

-- Composition of functions preserves convergence
-- Given
--   f : X → Y, g : Y → Z: functions
--   F, G, H: filters of X, Y, Z
-- If
--   f tends to G along F
--   g tends to H along G
-- Then
--   g ∘ f tends to H along F

-- Proof using the universal quantifier
example {X Y Z : Type*} {F : Filter X} {G : Filter Y} {H : Filter Z} {f : X → Y} {g : Y → Z}
    (hf : Tendsto₁ f F G) (hg : Tendsto₁ g G H) : Tendsto₁ (g ∘ f) F H :=

  -- Short:
  -- fun V hVH => hf (g⁻¹' V) (hg V hVH)
  -- Long:
  by
  -- We have: ∀ V ∈ H, g⁻¹(V) ∈ G and ∀ V ∈ G, f⁻¹(V) ∈ F.
  -- Show (g ∘ f)⁻¹(V) ∈ F for all V ∈ H.
  rw [Tendsto₁] at *
  intro V hVH
  -- Show f⁻¹(g⁻¹(V)) ∈ F.
  rw [preimage_comp]
  -- If we show g⁻¹(V) ∈ G, then f⁻¹(g⁻¹(V)) ∈ F. Show g⁻¹(V) ∈ G.
  apply hf
  -- Since V ∈ H, g⁻¹(V) ∈ G.
  exact hg V hVH

-- Proof using the algebraic definition and the two lemmas
example {X Y Z : Type*} {F : Filter X} {G : Filter Y} {H : Filter Z} {f : X → Y} {g : Y → Z}
    (hf : Tendsto₂ f F G) (hg : Tendsto₂ g G H) : Tendsto₂ (g ∘ f) F H :=
  -- `map (g ∘ f) F` = `map g (map f F)` (∵ map of composition)
  --                 ≤ `map g G` (∵ `map f F` ≤ G ∵ `Tendsto₂ f F G`)
  --                 = H (∵ `Tendsto₂ g G H`)
  calc
    map (g ∘ f) F = map g (map f F) := by rw [map_map]
    _             ≤ map g G := map_mono hf
    _             ≤ H := hg

-- `Filter.comap`: pullback operation on filters
--   generalize preimage operation on sets
-- For any map f : X → Y and filter G on Y,
-- `comap f G` is a filter on X
--   containing sets U s.t. ∃ V ∈ G, f⁻¹(V) ⊆ U.

-- Galois connection between `map` and `comap`
--   map f F ≤ G ↔ F ≤ comap f G

-- Another formulation of `Tendsto`
def Tendsto₃ {X Y : Type*} (f : X → Y) (F : Filter X) (G : Filter Y) :=
  F ≤ comap f G

-- The two definitions are provably (but not definitionally) equivalent.
-- Proof using the algebraic definition and the Galois connection
example {X Y : Type*} (f : X → Y) (F : Filter X) (G : Filter Y) :
    Tendsto₃ f F G ↔ Tendsto₂ f F G := by
  exact map_le_iff_le_comap.symm

-- Let f be a function from ℝ to ℝ.
-- Let x₀, y₀ be real numbers.
variable (f : ℝ → ℝ) (x₀ y₀ : ℝ)

-- `(↑) : ℚ → ℝ`: coercion from rationals to reals
-- `𝓝 x₀`: neighborhood filter of x₀
-- `comap ((↑) : ℚ → ℝ) (𝓝 x₀)`: pull back `𝓝 x₀` to ℚ under `(↑)`
--   restricts the filter to the rationals near x₀ (as a filter on ℚ)
#check comap ((↑) : ℚ → ℝ) (𝓝 x₀)

-- as rationals x approach x₀, f(x) approaches y₀
-- `f ∘ (↑)`: apply f to the rationals by first converting them to reals
#check Tendsto (f ∘ (↑)) (comap ((↑) : ℚ → ℝ) (𝓝 x₀)) (𝓝 y₀)

section

-- Let α, β, γ be types.
-- Let F be a filter on α.
-- Let m : γ → β and n : β → α be functions.
variable {α β γ : Type*} (F : Filter α) {m : γ → β} {n : β → α}

-- `Filter.comap` is compatible with function composition
-- However, it is contravariant (not covariant like `map`) in the function
--   it reverses the order of functions
#check (comap_comap : comap m (comap n F) = comap (n ∘ m) F)

end

-- `Filter.prod`: product filter
--   takes two filters on X, Y
--   produces a filter on X × Y
--   denoted by ×ˢ

-- The neighborhood filter of a point (x₀, y₀) in ℝ × ℝ
-- is the product filter of the neighborhood filters of x₀ and y₀
-- A set is in the neighborhood filter of (x₀, y₀)
-- iff it contains a product of neighborhoods of x₀ and y₀.
example : 𝓝 (x₀, y₀) = 𝓝 x₀ ×ˢ 𝓝 y₀ :=
  nhds_prod_eq

-- Product filter
--   combines information from two filters
--   captures "nearness" in the product space
--   by taking infimum of the pullbacks of the two filters along the projections
--   includes sets that are "large" in both filters
-- `Prod.fst`, `Prod.snd`: projections from X × Y to X, Y
-- `comap Prod.fst F`, `comap Prod.snd G`:
--   pull back F, G to X × Y under `Prod.fst`, `Prod.snd`
-- `⊓`: infimum of filters (generalization of intersection)
example (F G : Filter ℝ) : F ×ˢ G = (comap Prod.fst F) ⊓ (comap Prod.snd G) := rfl

-- a ≤ b ⊓ c ↔ a ≤ b and a ≤ c
#check le_inf_iff

-- A sequence (fₙ) in ℝ² converges to (x₀, y₀)
-- iff the first and second components of the sequence converge to x₀ and y₀
example (f : ℕ → ℝ × ℝ) (x₀ y₀ : ℝ) :
    Tendsto f atTop (𝓝 (x₀, y₀)) ↔
      Tendsto (Prod.fst ∘ f) atTop (𝓝 x₀) ∧ Tendsto (Prod.snd ∘ f) atTop (𝓝 y₀) :=
  by
  constructor
  · -- Suppose fₙ tends to (x₀, y₀) as n → ∞.
    -- In other words, f(`atTop`) ≤ 𝓝(x₀, y₀).
    -- Show that the first and second components of fₙ tend to x₀ and y₀.
    -- In other words, show (`Prod.fst` ∘ f)(`atTop`) ≤ 𝓝 x₀ and (`Prod.snd` ∘ f)(`atTop`) ≤ 𝓝 y₀.
    intro h
    constructor
    · -- Show that the first component of fₙ tends to x₀.
      -- (`Prod.fst` ∘ f)(`atTop`) = `Prod.fst`(f(`atTop`)) (∵ `map` of composition)
      --                           ≤ `Prod.fst`(𝓝(x₀, y₀)) (∵ `map` is monotone)
      --                           = `Prod.fst`(𝓝(x₀) × 𝓝(y₀))
      --                           = 𝓝 x₀
      calc
        map (Prod.fst ∘ f) atTop = map Prod.fst (map f atTop) := by rw [map_map]
        _ ≤ map Prod.fst (𝓝 (x₀, y₀)) := map_mono h
        _ = map Prod.fst (𝓝 x₀ ×ˢ 𝓝 y₀) := by rw [nhds_prod_eq]
        _ = 𝓝 x₀ := map_fst_prod (𝓝 x₀) (𝓝 y₀)
    · -- Show that the second component of fₙ tends to y₀.
      -- (`Prod.snd` ∘ f)(`atTop`) = `Prod.snd`(f(`atTop`)) (∵ `map` of composition)
      --                           ≤ `Prod.snd`(𝓝(x₀, y₀)) (∵ `map` is monotone)
      --                           = `Prod.snd`(𝓝(x₀) × 𝓝(y₀))
      --                           = 𝓝 y₀
      calc
        map (Prod.snd ∘ f) atTop = map Prod.snd (map f atTop) := by rw [map_map]
        _ ≤ map Prod.snd (𝓝 (x₀, y₀)) := map_mono h
        _ = map Prod.snd (𝓝 x₀ ×ˢ 𝓝 y₀) := by rw [nhds_prod_eq]
        _ = 𝓝 y₀ := map_snd_prod (𝓝 x₀) (𝓝 y₀)
  · -- Suppose the first and second components of fₙ tend to x₀ and y₀.
    -- In other words, (`Prod.fst` ∘ f)(`atTop`) ≤ 𝓝(x₀) and (`Prod.snd` ∘ f)(`atTop`) ≤ 𝓝(y₀).
    -- Show that fₙ tends to (x₀, y₀).
    -- In other words, show f(`atTop`) ≤ 𝓝(x₀, y₀).
    repeat rw [Tendsto]
    intro ⟨h, h'⟩

    -- Not-very-clean proof:
    -- Since `map` is compatible with function composition,
    --   (`Prod.fst` ∘ f)(`atTop`) = `Prod.fst`(f(`atTop`)) and
    --   (`Prod.snd` ∘ f)(`atTop`) = `Prod.snd`(f(`atTop`))
    -- Thus, `Prod.fst`(f(`atTop`)) ≤ 𝓝(x₀) and `Prod.snd`(f(`atTop`)) ≤ 𝓝(y₀).
    rw [← map_map] at h h'
    -- Using the Galois connection of `map` and `comap`, we have
    --  f(`atTop`) ≤ `Prod.fst`⁻¹(𝓝(x₀)) and
    --  f(`atTop`) ≤ `Prod.snd`⁻¹(𝓝(y₀))
    rw [map_le_iff_le_comap] at h h'
    -- Thus, f(`atTop`) ≤ `Prod.fst`⁻¹(𝓝(x₀)) ⊓ `Prod.snd`⁻¹(𝓝(y₀)).
    have := le_inf_iff.mpr ⟨h, h'⟩
    -- In other words, f(`atTop`) ≤ 𝓝(x₀) ×ˢ 𝓝(y₀) = 𝓝(x₀, y₀)
    rw [← prod_eq_inf, ← nhds_prod_eq] at this
    exact this

    -- Cleaner:
    -- calc
    --   map f atTop ≤ comap Prod.fst (𝓝 x₀) ⊓ comap Prod.snd (𝓝 y₀) := by
    --     have h₁ : map f atTop ≤ comap Prod.fst (𝓝 x₀) := by
    --       rw [← map_le_iff_le_comap]
    --       rw [map_map]
    --       exact h
    --     have h₂ : map f atTop ≤ comap Prod.snd (𝓝 y₀) := by
    --       rw [← map_le_iff_le_comap]
    --       rw [map_map]
    --       exact h'
    --     exact le_inf h₁ h₂
    --   _ = 𝓝 (x₀, y₀) := by rw [← prod_eq_inf, ← nhds_prod_eq]

-- The ordered type `Filter X` is a complete lattice
--   `(⊥ : Filter X)`: "smallest" filter, containing all subsets of X
--   `(⊤ : Filter X)`: "largest" filter, containing only X
--   `Filter.Inf`: infimum of a set of filters
--   `Filter.Sup`: supremum of a set of filters

example (X : Type) : (⊥ : Filter X) = 𝓟 ∅ := principal_empty.symm

example (X : Type) : (⊤ : Filter X) = 𝓟 univ := principal_univ.symm

-- All filters are non-empty because all filters contain the universe set

-- The empty set ∅ can be an element of a filter on X.
-- However, this leads to a trivial filter containing all subsets of X (⊥).

-- `principal`/`𝓟` can be defined without any precondition for dealing with ∅ (𝓟(∅) = ⊥).

-- `comap` can be defined without any precondition for dealing with ∅.
--   it can happen that f⁻¹(F) = ⊥ although F ≠ ⊥
--   Example: given x₀ ∈ ℝ and s ⊆ ℝ
--            the pullback of 𝓝 x₀ under the coercion from s is nontrivial
--            iff x₀ belongs to the closure of s
example (s : Set ℝ) :
  x₀ ∈ closure s ↔ comap ((↑) : s → ℝ) (𝓝 x₀) ≠ ⊥ :=
    Iff.trans
      mem_closure_iff_nhds_ne_bot
      (Iff.ne inf_principal_eq_bot_iff_comap)

-- Some lemmas require the nontriviality assumption
-- `Filter.NeBot`: type class of non-trivial filters
-- Ex: `atTop` is non-trivial
#check atTop_neBot
-- Ex: pushing forward a nontrivial filter results in a nontrivial filter
#check map_neBot

-- Convergence of a sequence (uₙ) to x₀ in ℝ
-- Tendsto definition:
--   preimage of *every* neighborhood of x₀ belongs to `atTop`
--   atTop ≤ comap u (𝓝 x₀)
#check tendsto_iff_comap
-- Previous definition:
--   preimage of any open interval around x₀, (x₀ - ε, x₀ + ε), belongs to `atTop`
-- Tendsto seems to be a stronger condition than the previous definition.

-- Filter basis:
--   a smaller collection of sets that can "generate" the filter
--   every set in the filter contains at least one of the sets in the basis
--   if the preimage of a basis set of filter A is in another filter B,
--   then all set of filter A is in filter B
-- Formally,
--   Given a filter F on X
--   A family of sets {sᵢ : i ∈ ι} is a basis of F if
--     ∀ U ⊆ X, U ∈ F ↔ ∃ i ∈ ι, sᵢ ⊆ U
-- In Lean, we can consider a predicate on ι that selects only of of its elements.
-- Example:
--   Neighborhood filter of x₀: `𝓝 x₀ : Filter ℝ`
--   ι = ℝ, i = ε: basis is indexed by ℝ, index denoted by ε
--   Predicate: ε > 0
-- `HasBasis`: the type class representing the concept of a filter having a basis
--   the filter (e.g., `𝓝 x₀`)
--   a predicate that selects the valid indices (e.g., ε ↦ ε > 0)
--   a function that maps the valid indices to the basis sets (e.g., ε ↦ (x₀ - ε, x₀ + ε))
example (x₀ : ℝ) : HasBasis (𝓝 x₀) (fun ε : ℝ ↦ 0 < ε) fun ε ↦ Ioo (x₀ - ε) (x₀ + ε) :=
  nhds_basis_Ioo_pos x₀

-- The basis of `atTop` is { {n ∈ ℕ | n ≥ N} | N ∈ ℕ }
-- `fun _ : ℕ ↦ True`: all natural numbers are valid indices
-- `Ici`: a function that maps N ∈ ℕ to {n ∈ ℕ | n ≥ N}
example : atTop.HasBasis (fun _ : ℕ ↦ True) Ici := atTop_basis

-- Convergence according to filters can be defined using filter bases
-- `Tendsto f F F'` with
--    filters F and F'
--    bases s and s'
--    indexed by ι and ι'
--    predicated by p and p'
-- is equivalent to
--   ∀ i ∈ p(ι), ∃ i' ∈ p'(ι') s.t. ∀ x ∈ s(i), f(x) ∈ s'(i')
#check HasBasis.tendsto_iff

-- Example: Convergence of a sequence (uₙ) to x₀ in ℝ as n → ∞
-- `Tendsto u atTop (𝓝 x₀)`
--   filters F = `atTop`, F' = 𝓝(x₀)
--   bases s = { {n ∈ ℕ | n ≥ N} | N ∈ ℕ }, s' = { (x₀ - ε, x₀ + ε) | ε > 0 }
--   indices ι = ℕ, ι' = ℝ
--   predicates p(ι) = ℕ, p'(ι') = { ε ∈ ℝ | ε > 0 }
-- is equivalent to
--   ∀ ε > 0, ∃ N ∈ ℕ, ∀ n ≥ N, uₙ ∈ (x₀ - ε, x₀ + ε)
example (u : ℕ → ℝ) (x₀ : ℝ) :
    Tendsto u atTop (𝓝 x₀) ↔ ∀ ε > 0, ∃ N, ∀ n ≥ N, u n ∈ Ioo (x₀ - ε) (x₀ + ε) := by
  rw [atTop_basis.tendsto_iff (nhds_basis_Ioo_pos x₀)]
  simp_rw [true_and, mem_Ici]

-- Long proof using the universal quantifier:
-- `P n` holds for sufficiently large n = `∃ N, ∀ n ≥ N, P n`
-- `Q n` holds for sufficiently large n = `∃ N, ∀ n ≥ N, Q n`
-- Using `cases`, we get `N_P` and `N_Q` s.t.
--   `∀ n ≥ N_P, P n` and `∀ n ≥ N_Q, Q n`
-- Let `N = max(N_P, N_Q)`. Then, `∀ n ≥ N, P n` and `∀ n ≥ N, Q n`.
-- Thus, `∀ n ≥ N, P n ∧ Q n`.

-- Shorter proof using the algebraic definition:
-- `P n` holds for sufficiently large n = { n | P n } ∈ `atTop`
-- `Q n` holds for sufficiently large n = { n | Q n } ∈ `atTop`
-- Then, { n | P n ∧ Q n } = { n | P n } ∩ { n | Q n } ∈ `atTop`.

-- { n | P n } ∈ `atTop` = `∀ᶠ n in atTop, P n`

-- `∀ᶠ x in F, P x`: notation for `Filter.Eventually P F`
-- `Filter.Eventually.and`: intersection of two `Filter.Eventually` predicates
--   if ∀ᶠ x ∈ F, P x and ∀ᶠ x ∈ F, Q x
--   then ∀ᶠ x ∈ F, P x ∧ Q x
example (P Q : ℕ → Prop) (hP : ∀ᶠ n in atTop, P n) (hQ : ∀ᶠ n in atTop, Q n) :
    ∀ᶠ n in atTop, P n ∧ Q n :=
  Filter.Eventually.and hP hQ

-- If two sequences eventually coincides, then they have the same limit.
-- Formally, if (uₙ) = (vₙ) for sufficiently large n,
--           then (uₙ) converges to x₀ iff (vₙ) converges to x₀.
-- Two ways to express the "eventually coincides" condition:
-- 1. `∀ᶠ n in atTop, u n = v n`
example (u v : ℕ → ℝ) (h : ∀ᶠ n in atTop, u n = v n) (x₀ : ℝ) :
    Tendsto u atTop (𝓝 x₀) ↔ Tendsto v atTop (𝓝 x₀) :=
  tendsto_congr' h

-- 2. `u = ᶠ[atTop] v` = `EventuallyEq atTop u v`
example (u v : ℕ → ℝ) (h : u =ᶠ[atTop] v) (x₀ : ℝ) :
    Tendsto u atTop (𝓝 x₀) ↔ Tendsto v atTop (𝓝 x₀) :=
  tendsto_congr' h

-- Filter axioms can be interpreted with Eventually
-- Given filter F on X and predicates P, Q on X.

-- `univ ∈ F`
-- If
--   P(x) is true for all x in X,
-- then
--   eventually P(x) is true along F.
-- `(∀ x ∈ X, P x) → (∀ᶠ x in F, P x)`
#check Filter.Eventually.of_forall

-- `U ∈ F → U ⊆ V → V ∈ F`
-- If
--   P(x) is eventually true along F
--   P(x) implies Q(x) for all x in X,
-- then
--   eventually Q(x) is true along F.
-- `(∀ᶠ x in F, P x) → (∀ x ∈ X, P x → Q x) → (∀ᶠ x in F, Q x)`
#check Filter.Eventually.mono

-- `U ∈ F → V ∈ F → U ∩ V ∈ F`
-- If
--   P(x) is eventually true along F
--   Q(x) is eventually true along F
-- then
--   P(x) ∧ Q(x) is eventually true along F
-- `(∀ᶠ x in F, P x) → (∀ᶠ x in F, Q x) → (∀ᶠ x in F, P x ∧ Q x)`
#check Filter.Eventually.and

-- If
--   P(n) is true for sufficiently large n
--   Q(n) is true for sufficiently large n
--   P(n) ∧ Q(n) implies R(n) for sufficiently large n
-- then
--   R(n) is true for sufficiently large n
example (P Q R : ℕ → Prop) (hP : ∀ᶠ n in atTop, P n) (hQ : ∀ᶠ n in atTop, Q n)
    (hR : ∀ᶠ n in atTop, P n ∧ Q n → R n) : ∀ᶠ n in atTop, R n := by
  -- Show: R(n) is true for sufficiently large n.
  -- We have:
  --   Q(n) is true for sufficiently large n
  --   P(n) ∧ Q(n) implies R(n) for sufficiently large n
  -- Thus:
  --   Q(n) ∧ (P(n) ∧ Q(n) → R(n)) is true for sufficiently large n.
  -- We also have:
  --   P(n) is true for sufficiently large n
  -- Thus:
  --   P(n) ∧ (Q(n) ∧ (P(n) ∧ Q(n) → R(n))) is true for sufficiently large n.
  -- Now, if we have
  --   P(n) ∧ (Q(n) ∧ (P(n) ∧ Q(n) → R(n))) → R(n) is always true
  -- Then we will have what we need to show. Thus, we show the above.
  apply (hP.and (hQ.and hR)).mono
  -- Show: ∀ n ∈ ℕ, P(n) ∧ (Q(n) ∧ (P(n) ∧ Q(n) → R(n))) → R(n) is true
  -- Fix n ∈ ℕ. Suppose P(n), Q(n), P(n) ∧ Q(n) → R(n) are true.
  -- Show: R(n) is true.
  rintro n ⟨h, h', h''⟩
  -- Since P(n) and Q(n) are true, P(n) ∧ Q(n) is true.
  -- Since P(n) ∧ Q(n) implies R(n), R(n) is true.
  exact h'' ⟨h, h'⟩

example (P Q R : ℕ → Prop) (hP : ∀ᶠ n in atTop, P n) (hQ : ∀ᶠ n in atTop, Q n)
    (hR : ∀ᶠ n in atTop, P n ∧ Q n → R n) : ∀ᶠ n in atTop, R n := by
  -- Since
  --   P(n) is true for sufficiently large n
  --   Q(n) is true for sufficiently large n
  --   P(n) ∧ Q(n) implies R(n) for sufficiently large n
  -- there is a large enough n s.t. P(n), Q(n), P(n) ∧ Q(n) → R(n) are true.
  -- Consider that n ∈ ℕ as "large enough".
  -- If R(n) is true, then we can conclude
  -- that R(n) is true for sufficiently large n.
  filter_upwards [hP, hQ, hR] with n h h' h''
  exact h'' ⟨h, h'⟩

-- `∃ᶠ x in F, P x`:
--   means `{x | ¬ P x} ∉ F`
--     there is no "large" set where P is false
--     P(x) is infinitely often true along F
--   notation for `Filter.Frequently P F`
-- Ex: `∃ᶠ n in atTop, P n` means P(n) is true for infinitely many n
--   i.e., there are arbitrarily large n s.t. P(n) is true
example : (∃ᶠ n in atTop, n % 2 = 0) := Nat.frequently_mod_eq Nat.zero_lt_two

-- `ClusterPt x F` is defined as `(𝓝 x ⊓ F).NeBot`
-- x is a cluster point of a filter F
-- neighborhoods of x intersected with F are non-empty
example {X : Type} [TopologicalSpace X] (x : X) (F : Filter X) :
  ClusterPt x F = (𝓝 x ⊓ F).NeBot := rfl

#check mem_closure_iff_clusterPt
#check le_principal_iff
#check neBot_of_le

-- Given
--   a sequence (uₙ: ℕ → ℝ)
--   a set M ⊆ ℝ
--   a real number x
-- If
--   uₙ converges to x as n → ∞
--   uₙ is in M for sufficiently large n
-- Then
--   x is in the closure of M
example (u : ℕ → ℝ) (M : Set ℝ) (x : ℝ) (hux : Tendsto u atTop (𝓝 x))
    (huM : ∀ᶠ n in atTop, u n ∈ M) : x ∈ closure M :=
  -- Short proof:
  -- mem_closure_iff_clusterPt.mpr (neBot_of_le (le_inf hux (le_principal_iff.mpr huM)))
  -- Long proof:
  by
  -- Show: x is in the closure of M.
  -- A point x is in the closure of M iff
  -- x is a cluster point of the principal filter of M.
  -- Show: x is a cluster point of the principal filter of M.
  apply mem_closure_iff_clusterPt.mpr
  -- By definition of cluster point,
  -- Show: 𝓝 x ⊓ 𝓟 M is non-trivial
  rw [ClusterPt]
  -- Plan: Show that 𝓝(x) ⊓ 𝓟(M) is "larger" than a non-trivial filter.
  -- Show: u(`atTop`) ≤ 𝓝(x) ⊓ 𝓟(M).
  have : map u atTop ≤ 𝓝 x ⊓ 𝓟 M := by
    -- Show: u(`atTop`) ≤ 𝓝(x).
    have h₁ : map u atTop ≤ 𝓝 x := by
      -- Since uₙ converges to x, u(`atTop`) ≤ 𝓝(x).
      rw [Tendsto] at hux
      -- Show: u(`atTop`) ≤ 𝓝(x).
      exact hux
    -- Show: u(`atTop`) ≤ 𝓟(M).
    have h₂ : map u atTop ≤ 𝓟 M := by
      -- Since uₙ ∈ M for sufficiently large n, M ∈ u(`atTop`).
      have : M ∈ map u atTop := huM
      -- Then, u(`atTop`) ≤ 𝓟(M).
      exact le_principal_iff.mpr this
    exact le_inf h₁ h₂
  -- Since `atTop` is non-trivial, u(`atTop`) is non-trivial,
  -- and thus, 𝓝 x ⊓ 𝓟 M is non-trivial.
  exact neBot_of_le this

-- Above is a special version of `mem_closure_of_tendsto`
-- where the topological space and the filter can be arbitrary.
#check mem_closure_of_tendsto
