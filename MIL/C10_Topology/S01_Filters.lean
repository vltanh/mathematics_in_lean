import MIL.Common
import Mathlib.Topology.Instances.Real

open Set Filter Topology

/-
Filter F on a set X: collection of subsets of X s.t.
  contains the universe: X âˆˆ F
    `F.univ_sets : univ âˆˆ F.sets`
  upward closed: if U âˆˆ F and U âŠ† V then V âˆˆ F
    `F.sets_of_superset : âˆ€ {U V}, U âˆˆ F.sets â†’ U âŠ† V â†’ V âˆˆ F.sets`
  closed under finite intersections: if U, v âˆˆ F then U âˆ© V âˆˆ F
    `F.inter_sets : âˆ€ {U, V}, U âˆˆ F.sets â†’ V âˆˆ F.sets â†’ U âˆ© V âˆˆ F.sets`

Intuition: F contains "large" or "significant" subsets of X

Examples:
  `atTop : Filter â„•`: "tails" of natural numbers
    containing sets of the form {n âˆˆ N | n â‰¥ N} where N âˆˆ â„•
    ex: {3, 4, 5, ...} âˆˆ `atTop`
  `ğ“ x`: neighborhood filter of a point x in a topological space
    containing neighborhoods of x
    ex: (6 - Îµ, 6 + Îµ) âˆˆ `ğ“ 6`, âˆ€ Îµ > 0

In Lean/Mathlib:
  `F` is implemented as a structure bundling
    `F.sets : Set (Set X)`: collection of sets
    `F.univ_sets`, `F.sets_of_superset`, `F.inter_sets`: filter axioms
  `(U âˆˆ F) = (U âˆˆ F.sets)`: simplifying notation
-/

-- Principal filter of a set s (generated by s)
--   contains sets that contain s {t | s âŠ† t}
--   denoted ğ“Ÿ s
def principal {Î± : Type*} (s : Set Î±) : Filter Î±
    where
  sets := { t | s âŠ† t }
  univ_sets :=
    -- The universe set X is the superset of all sets, including s.
    -- Therefore, the principal filter contains the universe set.
    subset_univ s
  sets_of_superset :=
    -- Let t be a subset of X.
    -- Suppose t âˆˆ ğ“Ÿ s. Then, s âŠ† t.
    -- If t âŠ† u then s âŠ† u. Thus, u âˆˆ ğ“Ÿ s.
    Subset.trans
  inter_sets :=
    -- Let t, u be subsets of X.
    -- Suppose t, u âˆˆ ğ“Ÿ s. Then, s âŠ† t and s âŠ† u.
    -- Then, s âŠ† t âˆ© u. Thus, t âˆ© u âˆˆ ğ“Ÿ s.
    subset_inter

-- `atTop`/"tails" filter on â„• (or any type with a preorder)
example : Filter â„• :=
  { sets := { s | âˆƒ a, âˆ€ b, a â‰¤ b â†’ b âˆˆ s }
    univ_sets := by
      -- We need to show that âˆƒ a âˆˆ â„•, âˆ€ b âˆˆ â„•, a â‰¤ b â†’ b âˆˆ univ.
      -- Let a = 0.
      use 0
      -- Let b âˆˆ â„• and b â‰¥ 0 (= a).
      intro _ _
      -- Then b âˆˆ â„• (= univ).
      trivial
    sets_of_superset := by
      -- Let x âŠ† y âŠ† â„•.
      -- Let x âˆˆ `atTop` with lower bound a.
      -- We need to show that y âˆˆ `atTop`,
      -- i.e., âˆƒ a' âˆˆ â„•, âˆ€ b âˆˆ â„•, a' â‰¤ b â†’ b âˆˆ y.
      intro x y âŸ¨a, haâŸ© hxy
      -- Let a' = a.
      use a
      -- Let b âˆˆ â„• and b â‰¥ a'.
      intro b hb
      -- Then, b â‰¥ a (âˆµ a = a'). So, b âˆˆ x.
      -- Since x âŠ† y, b âˆˆ y.
      exact hxy (ha b hb)
    inter_sets := by
      -- Let x, y âˆˆ `atTop` with lower bounds ax, ay.
      -- We need to show that x âˆ© y âˆˆ `atTop`,
      -- i.e., âˆƒ a âˆˆ â„•, âˆ€ b âˆˆ â„•, a â‰¤ b â†’ b âˆˆ x âˆ© y.
      intro x y âŸ¨ax, hxâŸ© âŸ¨ay, hyâŸ©
      -- Let a = max(ax, ay).
      use max ax ay
      -- Let b âˆˆ â„• and b â‰¥ a.
      intro b hb
      -- We need to show b âˆˆ x and b âˆˆ y.
      constructor
      Â· -- Since b â‰¥ a = max(ax, ay) â‰¥ ax, b âˆˆ x.
        exact hx b (le_of_max_le_left hb)
      Â· -- Similarly, b âˆˆ y.
        exact hy b (le_of_max_le_right hb)
  }

-- Neighborhood filter of a xâ‚€
--   containing neighborhoods of xâ‚€
--     neighborhood of xâ‚€: set containing an open interval (xâ‚€ - Îµ, xâ‚€ + Îµ)
--   denoted ğ“ xâ‚€
example (xâ‚€ : â„) : Filter â„ where
  sets := { s | âˆƒ Îµ > 0, Ioo (xâ‚€ - Îµ) (xâ‚€ + Îµ) âŠ† s }
  univ_sets := by
    -- Show: âˆƒ Îµ > 0, (xâ‚€ - Îµ, xâ‚€ + Îµ) âŠ† â„
    -- Let Îµ = 1. Show: 1 > 0 and (xâ‚€ - 1, xâ‚€ + 1) âŠ† â„.
    use 1
    constructor
    Â· -- 1 > 0 is trivial.
      exact Real.zero_lt_one
    Â· -- If x âˆˆ (xâ‚€ - 1, xâ‚€ + 1), then x âˆˆ â„ trivially.
      intro x _
      trivial
  sets_of_superset := by
    -- Let s âŠ† t âŠ† â„.
    -- Let s âˆˆ ğ“ xâ‚€ with "radius" Îµ > 0.
    -- Then, (xâ‚€ - Îµ, xâ‚€ + Îµ) âŠ† s.
    -- Show: âˆƒ Îµ' > 0, (xâ‚€ - Îµ', xâ‚€ + Îµ') âŠ† t.
    rintro s t âŸ¨Îµ, Îµ_pos, hsâŸ© hst
    -- Let Îµ' = Îµ. Show: Îµ' > 0 and (xâ‚€ - Îµ', xâ‚€ + Îµ') âŠ† t.
    use Îµ
    constructor
    Â· -- Then, Îµ' = Îµ > 0.
      exact Îµ_pos
    Â· -- And, (xâ‚€ - Îµ', xâ‚€ + Îµ') = (xâ‚€ - Îµ, xâ‚€ + Îµ) âŠ† s âŠ† t.
      exact Subset.trans hs hst
  inter_sets := by
    -- Let s, t âˆˆ ğ“ xâ‚€ with "radii" Îµs, Îµt > 0.
    -- Then, (xâ‚€ - Îµs, xâ‚€ + Îµs) âŠ† s and (xâ‚€ - Îµt, xâ‚€ + Îµt) âŠ† t.
    -- Show: âˆƒ Îµ > 0, (xâ‚€ - Îµ, xâ‚€ + Îµ) âŠ† s âˆ© t.
    rintro s t âŸ¨Îµs, Îµs_pos, hsâŸ© âŸ¨Îµt, Îµt_pos, htâŸ©
    -- Let Îµ = min(Îµs, Îµt).
    -- Show: Îµ > 0 and (xâ‚€ - Îµ, xâ‚€ + Îµ) âŠ† s âˆ© t.
    use min Îµs Îµt
    constructor
    Â· -- Since Îµs, Îµt > 0, Îµ = min(Îµs, Îµt) > 0.
      exact lt_min Îµs_pos Îµt_pos
    Â· -- Let x âˆˆ (xâ‚€ - Îµ, xâ‚€ + Îµ).
      rintro x âŸ¨hxl, hxrâŸ©
      -- Show x âˆˆ s âˆ© t by showing x âˆˆ s and x âˆˆ t.
      constructor
      Â· -- Since (xâ‚€ - Îµs, xâ‚€ + Îµs) âŠ† s, show x âˆˆ (xâ‚€ - Îµs, xâ‚€ + Îµs).
        apply hs
        -- Show xâ‚€ - Îµs < x and x < xâ‚€ + Îµs.
        constructor
        Â· -- xâ‚€ - Îµs â‰¤ xâ‚€ - min(Îµs, Îµt) = xâ‚€ - Îµ < x.
          calc
            xâ‚€ - Îµs â‰¤ xâ‚€ - min Îµs Îµt := tsub_le_tsub_left (min_le_left Îµs Îµt) xâ‚€
            _ < x := hxl
        Â· -- x < xâ‚€ + min(Îµs, Îµt) â‰¤ xâ‚€ + Îµs
          calc
            x < xâ‚€ + min Îµs Îµt := hxr
            _ â‰¤ xâ‚€ + Îµs := add_le_add_left (min_le_left Îµs Îµt) xâ‚€
      Â· -- Since (xâ‚€ - Îµs, xâ‚€ + Îµs) âŠ† s, show x âˆˆ (xâ‚€ - Îµs, xâ‚€ + Îµs).
        apply ht
        -- Show xâ‚€ - Îµs < x and x < xâ‚€ + Îµs.
        constructor
        Â· -- xâ‚€ - Îµs â‰¤ xâ‚€ - min(Îµs, Îµt) = xâ‚€ - Îµ < x.
          calc
            xâ‚€ - Îµt â‰¤ xâ‚€ - min Îµs Îµt := tsub_le_tsub_left (min_le_right Îµs Îµt) xâ‚€
            _ < x := hxl
        Â· -- x < xâ‚€ + min(Îµs, Îµt) â‰¤ xâ‚€ + Îµs
          calc
            x < xâ‚€ + min Îµs Îµt := hxr
            _ â‰¤ xâ‚€ + Îµt := add_le_add_left (min_le_right Îµs Îµt) xâ‚€

-- For any V âˆˆ G (filter on Y), preimage of V under f is in F (filter on X).
-- Intuition: as x "approaches" a value/concept according to F,
--            f(x) "approaches" a value/concept according to G.
-- Example:
-- 1. X = â„•, Y = â„, F = `atTop`, G = ğ“ x
--    `Tendstoâ‚ u atTop (ğ“ x)`: sequence (uâ‚™) converges to x
--      as n "approaches" infinity (according to `atTop`),
--      uâ‚™ "approaches" x (according to ğ“ x)
-- 2. X = Y = â„, F = ğ“ xâ‚€, G = ğ“ yâ‚€
--    `Tendstoâ‚ f (ğ“ xâ‚€) (ğ“ yâ‚€)`: function f has the limit yâ‚€ as x approaches xâ‚€
def Tendstoâ‚ {X Y : Type*} (f : X â†’ Y) (F : Filter X) (G : Filter Y) :=
  âˆ€ V âˆˆ G, f â»Â¹' V âˆˆ F

-- `Filter.map f F` is a filter on Y containing V s.t. fâ»Â¹(V) âˆˆ F
--   a set V is in the pushed-forward filter iff
--   its preimage under f is in the original filter
example {X Y : Type*} (f : X â†’ Y) (F : Filter X) : Filter Y where
  sets := { V | f â»Â¹' V âˆˆ F }
  univ_sets :=
    -- The preimage of the universe set under any function is the universe set.
    -- The universe set is a member of the filter F.
    F.univ_mem
  sets_of_superset := by
    -- Let U âŠ† V âŠ† Y.
    -- Suppose U âˆˆ `map f F`. Show V âˆˆ `map f F`.
    intro U V hU hUV
    -- Since U âˆˆ `map f F`, fâ»Â¹(U) âˆˆ F.
    -- Since U âŠ† V, fâ»Â¹(U) âŠ† fâ»Â¹(V). Thus, fâ»Â¹(V) âˆˆ F.
    -- Thus, V âˆˆ `map f F`.
    apply F.sets_of_superset hU (fun x hxfinvU â†¦ hUV hxfinvU)
  inter_sets := by
    -- Let U, V âˆˆ `map f F`.
    -- Then, fâ»Â¹(U), fâ»Â¹(V) âˆˆ F.
    -- Then, fâ»Â¹(U âˆ© V) = fâ»Â¹(U) âˆ© fâ»Â¹(V) âˆˆ F.
    -- Thus, U âˆ© V âˆˆ `map f F`.
    intro U V hU hV
    exact Filter.inter_sets F hU hV

-- IMPORTANT: order relation in filter is the *reverse* inclusion
--   F â‰¤ G iff G âŠ† F
--   Intuition: sets considered large by G are also considered large by F
--              F has a less strict notion of largeness than G
--   Example: If A âŠ† B âŠ† X, then ğ“Ÿ A â‰¤ ğ“Ÿ B
--     intuitively, ğ“Ÿ A (resp. ğ“Ÿ B) requires a set to contain A (resp. B) to be "large"
--     since A âŠ† B, ğ“Ÿ A is less strict (since if a set contains B, it also contains A)
example {X : Type*} (A B : Set X) (h: A âŠ† B) : ğ“Ÿ A â‰¤ ğ“Ÿ B := by
  -- Let U âˆˆ ğ“Ÿ B.
  intro U hU
  -- Then, B âŠ† U.
  -- Since A âŠ† B, A âŠ† U.
  -- Thus, U âˆˆ ğ“Ÿ A.
  exact Subset.trans h hU

-- Filters on X = generalized subsets of X
--   any (sub)set s corresponds to a principal filter ğ“Ÿ s
def Tendstoâ‚‚ {X Y : Type*} (f : X â†’ Y) (F : Filter X) (G : Filter Y) :=
  map f F â‰¤ G

-- The two definitions are equivalent.
-- Drawback of `Tendstoâ‚`: quantifier over all V âˆˆ G
example {X Y : Type*} (f : X â†’ Y) (F : Filter X) (G : Filter Y) :
    Tendstoâ‚‚ f F G â†” Tendstoâ‚ f F G :=
  Iff.rfl

-- `Filter.map` is monotone
--   given m : Î± â†’ Î²,
--   if (F : Filter Î±) â‰¤ (G : Filter Î±)
--   then (map m F : Filter Î²) â‰¤ (map m G : Filter Î²)
#check (@Filter.map_mono : âˆ€ {Î± Î²} {m : Î± â†’ Î²}, Monotone (map m))

-- `Filter.map` is compatible with function composition
--   map (m' âˆ˜ m) F = map m' (map m F)
--   i.e., pushing forward under the composition of functions is the same as
--         pushing forward under the first function and then the second function
#check
  (@Filter.map_map :
    âˆ€ {Î± Î² Î³} {f : Filter Î±} {m : Î± â†’ Î²} {m' : Î² â†’ Î³}, map m' (map m f) = map (m' âˆ˜ m) f)

-- Composition of functions preserves convergence
-- Given
--   f : X â†’ Y, g : Y â†’ Z: functions
--   F, G, H: filters of X, Y, Z
-- If
--   f tends to G along F
--   g tends to H along G
-- Then
--   g âˆ˜ f tends to H along F

-- Proof using the universal quantifier
example {X Y Z : Type*} {F : Filter X} {G : Filter Y} {H : Filter Z} {f : X â†’ Y} {g : Y â†’ Z}
    (hf : Tendstoâ‚ f F G) (hg : Tendstoâ‚ g G H) : Tendstoâ‚ (g âˆ˜ f) F H :=

  -- Short:
  -- fun V hVH => hf (gâ»Â¹' V) (hg V hVH)
  -- Long:
  by
  -- We have: âˆ€ V âˆˆ H, gâ»Â¹(V) âˆˆ G and âˆ€ V âˆˆ G, fâ»Â¹(V) âˆˆ F.
  -- Show (g âˆ˜ f)â»Â¹(V) âˆˆ F for all V âˆˆ H.
  rw [Tendstoâ‚] at *
  intro V hVH
  -- Show fâ»Â¹(gâ»Â¹(V)) âˆˆ F.
  rw [preimage_comp]
  -- If we show gâ»Â¹(V) âˆˆ G, then fâ»Â¹(gâ»Â¹(V)) âˆˆ F. Show gâ»Â¹(V) âˆˆ G.
  apply hf
  -- Since V âˆˆ H, gâ»Â¹(V) âˆˆ G.
  exact hg V hVH

-- Proof using the algebraic definition and the two lemmas
example {X Y Z : Type*} {F : Filter X} {G : Filter Y} {H : Filter Z} {f : X â†’ Y} {g : Y â†’ Z}
    (hf : Tendstoâ‚‚ f F G) (hg : Tendstoâ‚‚ g G H) : Tendstoâ‚‚ (g âˆ˜ f) F H :=
  -- `map (g âˆ˜ f) F` = `map g (map f F)` (âˆµ map of composition)
  --                 â‰¤ `map g G` (âˆµ `map f F` â‰¤ G âˆµ `Tendstoâ‚‚ f F G`)
  --                 = H (âˆµ `Tendstoâ‚‚ g G H`)
  calc
    map (g âˆ˜ f) F = map g (map f F) := by rw [map_map]
    _             â‰¤ map g G := map_mono hf
    _             â‰¤ H := hg

-- `Filter.comap`: pullback operation on filters
--   generalize preimage operation on sets
-- For any map f : X â†’ Y and filter G on Y,
-- `comap f G` is a filter on X
--   containing sets U s.t. âˆƒ V âˆˆ G, fâ»Â¹(V) âŠ† U.

-- Galois connection between `map` and `comap`
--   map f F â‰¤ G â†” F â‰¤ comap f G

-- Another formulation of `Tendsto`
def Tendstoâ‚ƒ {X Y : Type*} (f : X â†’ Y) (F : Filter X) (G : Filter Y) :=
  F â‰¤ comap f G

-- The two definitions are provably (but not definitionally) equivalent.
-- Proof using the algebraic definition and the Galois connection
example {X Y : Type*} (f : X â†’ Y) (F : Filter X) (G : Filter Y) :
    Tendstoâ‚ƒ f F G â†” Tendstoâ‚‚ f F G := by
  exact map_le_iff_le_comap.symm

-- Let f be a function from â„ to â„.
-- Let xâ‚€, yâ‚€ be real numbers.
variable (f : â„ â†’ â„) (xâ‚€ yâ‚€ : â„)

-- `(â†‘) : â„š â†’ â„`: coercion from rationals to reals
-- `ğ“ xâ‚€`: neighborhood filter of xâ‚€
-- `comap ((â†‘) : â„š â†’ â„) (ğ“ xâ‚€)`: pull back `ğ“ xâ‚€` to â„š under `(â†‘)`
--   restricts the filter to the rationals near xâ‚€ (as a filter on â„š)
#check comap ((â†‘) : â„š â†’ â„) (ğ“ xâ‚€)

-- as rationals x approach xâ‚€, f(x) approaches yâ‚€
-- `f âˆ˜ (â†‘)`: apply f to the rationals by first converting them to reals
#check Tendsto (f âˆ˜ (â†‘)) (comap ((â†‘) : â„š â†’ â„) (ğ“ xâ‚€)) (ğ“ yâ‚€)

section

-- Let Î±, Î², Î³ be types.
-- Let F be a filter on Î±.
-- Let m : Î³ â†’ Î² and n : Î² â†’ Î± be functions.
variable {Î± Î² Î³ : Type*} (F : Filter Î±) {m : Î³ â†’ Î²} {n : Î² â†’ Î±}

-- `Filter.comap` is compatible with function composition
-- However, it is contravariant (not covariant like `map`) in the function
--   it reverses the order of functions
#check (comap_comap : comap m (comap n F) = comap (n âˆ˜ m) F)

end

-- `Filter.prod`: product filter
--   takes two filters on X, Y
--   produces a filter on X Ã— Y
--   denoted by Ã—Ë¢

-- The neighborhood filter of a point (xâ‚€, yâ‚€) in â„ Ã— â„
-- is the product filter of the neighborhood filters of xâ‚€ and yâ‚€
-- A set is in the neighborhood filter of (xâ‚€, yâ‚€)
-- iff it contains a product of neighborhoods of xâ‚€ and yâ‚€.
example : ğ“ (xâ‚€, yâ‚€) = ğ“ xâ‚€ Ã—Ë¢ ğ“ yâ‚€ :=
  nhds_prod_eq

-- Product filter
--   combines information from two filters
--   captures "nearness" in the product space
--   by taking infimum of the pullbacks of the two filters along the projections
--   includes sets that are "large" in both filters
-- `Prod.fst`, `Prod.snd`: projections from X Ã— Y to X, Y
-- `comap Prod.fst F`, `comap Prod.snd G`:
--   pull back F, G to X Ã— Y under `Prod.fst`, `Prod.snd`
-- `âŠ“`: infimum of filters (generalization of intersection)
example (F G : Filter â„) : F Ã—Ë¢ G = (comap Prod.fst F) âŠ“ (comap Prod.snd G) := rfl

-- a â‰¤ b âŠ“ c â†” a â‰¤ b and a â‰¤ c
#check le_inf_iff

-- A sequence (fâ‚™) in â„Â² converges to (xâ‚€, yâ‚€)
-- iff the first and second components of the sequence converge to xâ‚€ and yâ‚€
example (f : â„• â†’ â„ Ã— â„) (xâ‚€ yâ‚€ : â„) :
    Tendsto f atTop (ğ“ (xâ‚€, yâ‚€)) â†”
      Tendsto (Prod.fst âˆ˜ f) atTop (ğ“ xâ‚€) âˆ§ Tendsto (Prod.snd âˆ˜ f) atTop (ğ“ yâ‚€) :=
  by
  constructor
  Â· -- Suppose fâ‚™ tends to (xâ‚€, yâ‚€) as n â†’ âˆ.
    -- In other words, f(`atTop`) â‰¤ ğ“(xâ‚€, yâ‚€).
    -- Show that the first and second components of fâ‚™ tend to xâ‚€ and yâ‚€.
    -- In other words, show (`Prod.fst` âˆ˜ f)(`atTop`) â‰¤ ğ“ xâ‚€ and (`Prod.snd` âˆ˜ f)(`atTop`) â‰¤ ğ“ yâ‚€.
    intro h
    constructor
    Â· -- Show that the first component of fâ‚™ tends to xâ‚€.
      -- (`Prod.fst` âˆ˜ f)(`atTop`) = `Prod.fst`(f(`atTop`)) (âˆµ `map` of composition)
      --                           â‰¤ `Prod.fst`(ğ“(xâ‚€, yâ‚€)) (âˆµ `map` is monotone)
      --                           = `Prod.fst`(ğ“(xâ‚€) Ã— ğ“(yâ‚€))
      --                           = ğ“ xâ‚€
      calc
        map (Prod.fst âˆ˜ f) atTop = map Prod.fst (map f atTop) := by rw [map_map]
        _ â‰¤ map Prod.fst (ğ“ (xâ‚€, yâ‚€)) := map_mono h
        _ = map Prod.fst (ğ“ xâ‚€ Ã—Ë¢ ğ“ yâ‚€) := by rw [nhds_prod_eq]
        _ = ğ“ xâ‚€ := map_fst_prod (ğ“ xâ‚€) (ğ“ yâ‚€)
    Â· -- Show that the second component of fâ‚™ tends to yâ‚€.
      -- (`Prod.snd` âˆ˜ f)(`atTop`) = `Prod.snd`(f(`atTop`)) (âˆµ `map` of composition)
      --                           â‰¤ `Prod.snd`(ğ“(xâ‚€, yâ‚€)) (âˆµ `map` is monotone)
      --                           = `Prod.snd`(ğ“(xâ‚€) Ã— ğ“(yâ‚€))
      --                           = ğ“ yâ‚€
      calc
        map (Prod.snd âˆ˜ f) atTop = map Prod.snd (map f atTop) := by rw [map_map]
        _ â‰¤ map Prod.snd (ğ“ (xâ‚€, yâ‚€)) := map_mono h
        _ = map Prod.snd (ğ“ xâ‚€ Ã—Ë¢ ğ“ yâ‚€) := by rw [nhds_prod_eq]
        _ = ğ“ yâ‚€ := map_snd_prod (ğ“ xâ‚€) (ğ“ yâ‚€)
  Â· -- Suppose the first and second components of fâ‚™ tend to xâ‚€ and yâ‚€.
    -- In other words, (`Prod.fst` âˆ˜ f)(`atTop`) â‰¤ ğ“(xâ‚€) and (`Prod.snd` âˆ˜ f)(`atTop`) â‰¤ ğ“(yâ‚€).
    -- Show that fâ‚™ tends to (xâ‚€, yâ‚€).
    -- In other words, show f(`atTop`) â‰¤ ğ“(xâ‚€, yâ‚€).
    repeat rw [Tendsto]
    intro âŸ¨h, h'âŸ©

    -- Not-very-clean proof:
    -- Since `map` is compatible with function composition,
    --   (`Prod.fst` âˆ˜ f)(`atTop`) = `Prod.fst`(f(`atTop`)) and
    --   (`Prod.snd` âˆ˜ f)(`atTop`) = `Prod.snd`(f(`atTop`))
    -- Thus, `Prod.fst`(f(`atTop`)) â‰¤ ğ“(xâ‚€) and `Prod.snd`(f(`atTop`)) â‰¤ ğ“(yâ‚€).
    rw [â† map_map] at h h'
    -- Using the Galois connection of `map` and `comap`, we have
    --  f(`atTop`) â‰¤ `Prod.fst`â»Â¹(ğ“(xâ‚€)) and
    --  f(`atTop`) â‰¤ `Prod.snd`â»Â¹(ğ“(yâ‚€))
    rw [map_le_iff_le_comap] at h h'
    -- Thus, f(`atTop`) â‰¤ `Prod.fst`â»Â¹(ğ“(xâ‚€)) âŠ“ `Prod.snd`â»Â¹(ğ“(yâ‚€)).
    have := le_inf_iff.mpr âŸ¨h, h'âŸ©
    -- In other words, f(`atTop`) â‰¤ ğ“(xâ‚€) Ã—Ë¢ ğ“(yâ‚€) = ğ“(xâ‚€, yâ‚€)
    rw [â† prod_eq_inf, â† nhds_prod_eq] at this
    exact this

    -- Cleaner:
    -- calc
    --   map f atTop â‰¤ comap Prod.fst (ğ“ xâ‚€) âŠ“ comap Prod.snd (ğ“ yâ‚€) := by
    --     have hâ‚ : map f atTop â‰¤ comap Prod.fst (ğ“ xâ‚€) := by
    --       rw [â† map_le_iff_le_comap]
    --       rw [map_map]
    --       exact h
    --     have hâ‚‚ : map f atTop â‰¤ comap Prod.snd (ğ“ yâ‚€) := by
    --       rw [â† map_le_iff_le_comap]
    --       rw [map_map]
    --       exact h'
    --     exact le_inf hâ‚ hâ‚‚
    --   _ = ğ“ (xâ‚€, yâ‚€) := by rw [â† prod_eq_inf, â† nhds_prod_eq]

-- The ordered type `Filter X` is a complete lattice
--   `(âŠ¥ : Filter X)`: "smallest" filter, containing all subsets of X
--   `(âŠ¤ : Filter X)`: "largest" filter, containing only X
--   `Filter.Inf`: infimum of a set of filters
--   `Filter.Sup`: supremum of a set of filters

example (X : Type) : (âŠ¥ : Filter X) = ğ“Ÿ âˆ… := principal_empty.symm

example (X : Type) : (âŠ¤ : Filter X) = ğ“Ÿ univ := principal_univ.symm

-- All filters are non-empty because all filters contain the universe set

-- The empty set âˆ… can be an element of a filter on X.
-- However, this leads to a trivial filter containing all subsets of X (âŠ¥).

-- `principal`/`ğ“Ÿ` can be defined without any precondition for dealing with âˆ… (ğ“Ÿ(âˆ…) = âŠ¥).

-- `comap` can be defined without any precondition for dealing with âˆ….
--   it can happen that fâ»Â¹(F) = âŠ¥ although F â‰  âŠ¥
--   Example: given xâ‚€ âˆˆ â„ and s âŠ† â„
--            the pullback of ğ“ xâ‚€ under the coercion from s is nontrivial
--            iff xâ‚€ belongs to the closure of s
example (s : Set â„) :
  xâ‚€ âˆˆ closure s â†” comap ((â†‘) : s â†’ â„) (ğ“ xâ‚€) â‰  âŠ¥ :=
    Iff.trans
      mem_closure_iff_nhds_ne_bot
      (Iff.ne inf_principal_eq_bot_iff_comap)

-- Some lemmas require the nontriviality assumption
-- `Filter.NeBot`: type class of non-trivial filters
-- Ex: `atTop` is non-trivial
#check atTop_neBot
-- Ex: pushing forward a nontrivial filter results in a nontrivial filter
#check map_neBot

-- Convergence of a sequence (uâ‚™) to xâ‚€ in â„
-- Tendsto definition:
--   preimage of *every* neighborhood of xâ‚€ belongs to `atTop`
--   atTop â‰¤ comap u (ğ“ xâ‚€)
#check tendsto_iff_comap
-- Previous definition:
--   preimage of any open interval around xâ‚€, (xâ‚€ - Îµ, xâ‚€ + Îµ), belongs to `atTop`
-- Tendsto seems to be a stronger condition than the previous definition.

-- Filter basis:
--   a smaller collection of sets that can "generate" the filter
--   every set in the filter contains at least one of the sets in the basis
--   if the preimage of a basis set of filter A is in another filter B,
--   then all set of filter A is in filter B
-- Formally,
--   Given a filter F on X
--   A family of sets {sáµ¢ : i âˆˆ Î¹} is a basis of F if
--     âˆ€ U âŠ† X, U âˆˆ F â†” âˆƒ i âˆˆ Î¹, sáµ¢ âŠ† U
-- In Lean, we can consider a predicate on Î¹ that selects only of of its elements.
-- Example:
--   Neighborhood filter of xâ‚€: `ğ“ xâ‚€ : Filter â„`
--   Î¹ = â„, i = Îµ: basis is indexed by â„, index denoted by Îµ
--   Predicate: Îµ > 0
-- `HasBasis`: the type class representing the concept of a filter having a basis
--   the filter (e.g., `ğ“ xâ‚€`)
--   a predicate that selects the valid indices (e.g., Îµ â†¦ Îµ > 0)
--   a function that maps the valid indices to the basis sets (e.g., Îµ â†¦ (xâ‚€ - Îµ, xâ‚€ + Îµ))
example (xâ‚€ : â„) : HasBasis (ğ“ xâ‚€) (fun Îµ : â„ â†¦ 0 < Îµ) fun Îµ â†¦ Ioo (xâ‚€ - Îµ) (xâ‚€ + Îµ) :=
  nhds_basis_Ioo_pos xâ‚€

-- The basis of `atTop` is { {n âˆˆ â„• | n â‰¥ N} | N âˆˆ â„• }
-- `fun _ : â„• â†¦ True`: all natural numbers are valid indices
-- `Ici`: a function that maps N âˆˆ â„• to {n âˆˆ â„• | n â‰¥ N}
example : atTop.HasBasis (fun _ : â„• â†¦ True) Ici := atTop_basis

-- Convergence according to filters can be defined using filter bases
-- `Tendsto f F F'` with
--    filters F and F'
--    bases s and s'
--    indexed by Î¹ and Î¹'
--    predicated by p and p'
-- is equivalent to
--   âˆ€ i âˆˆ p(Î¹), âˆƒ i' âˆˆ p'(Î¹') s.t. âˆ€ x âˆˆ s(i), f(x) âˆˆ s'(i')
#check HasBasis.tendsto_iff

-- Example: Convergence of a sequence (uâ‚™) to xâ‚€ in â„ as n â†’ âˆ
-- `Tendsto u atTop (ğ“ xâ‚€)`
--   filters F = `atTop`, F' = ğ“(xâ‚€)
--   bases s = { {n âˆˆ â„• | n â‰¥ N} | N âˆˆ â„• }, s' = { (xâ‚€ - Îµ, xâ‚€ + Îµ) | Îµ > 0 }
--   indices Î¹ = â„•, Î¹' = â„
--   predicates p(Î¹) = â„•, p'(Î¹') = { Îµ âˆˆ â„ | Îµ > 0 }
-- is equivalent to
--   âˆ€ Îµ > 0, âˆƒ N âˆˆ â„•, âˆ€ n â‰¥ N, uâ‚™ âˆˆ (xâ‚€ - Îµ, xâ‚€ + Îµ)
example (u : â„• â†’ â„) (xâ‚€ : â„) :
    Tendsto u atTop (ğ“ xâ‚€) â†” âˆ€ Îµ > 0, âˆƒ N, âˆ€ n â‰¥ N, u n âˆˆ Ioo (xâ‚€ - Îµ) (xâ‚€ + Îµ) := by
  rw [atTop_basis.tendsto_iff (nhds_basis_Ioo_pos xâ‚€)]
  simp_rw [true_and, mem_Ici]

-- Long proof using the universal quantifier:
-- `P n` holds for sufficiently large n = `âˆƒ N, âˆ€ n â‰¥ N, P n`
-- `Q n` holds for sufficiently large n = `âˆƒ N, âˆ€ n â‰¥ N, Q n`
-- Using `cases`, we get `N_P` and `N_Q` s.t.
--   `âˆ€ n â‰¥ N_P, P n` and `âˆ€ n â‰¥ N_Q, Q n`
-- Let `N = max(N_P, N_Q)`. Then, `âˆ€ n â‰¥ N, P n` and `âˆ€ n â‰¥ N, Q n`.
-- Thus, `âˆ€ n â‰¥ N, P n âˆ§ Q n`.

-- Shorter proof using the algebraic definition:
-- `P n` holds for sufficiently large n = { n | P n } âˆˆ `atTop`
-- `Q n` holds for sufficiently large n = { n | Q n } âˆˆ `atTop`
-- Then, { n | P n âˆ§ Q n } = { n | P n } âˆ© { n | Q n } âˆˆ `atTop`.

-- { n | P n } âˆˆ `atTop` = `âˆ€á¶  n in atTop, P n`

-- `âˆ€á¶  x in F, P x`: notation for `Filter.Eventually P F`
-- `Filter.Eventually.and`: intersection of two `Filter.Eventually` predicates
--   if âˆ€á¶  x âˆˆ F, P x and âˆ€á¶  x âˆˆ F, Q x
--   then âˆ€á¶  x âˆˆ F, P x âˆ§ Q x
example (P Q : â„• â†’ Prop) (hP : âˆ€á¶  n in atTop, P n) (hQ : âˆ€á¶  n in atTop, Q n) :
    âˆ€á¶  n in atTop, P n âˆ§ Q n :=
  Filter.Eventually.and hP hQ

-- If two sequences eventually coincides, then they have the same limit.
-- Formally, if (uâ‚™) = (vâ‚™) for sufficiently large n,
--           then (uâ‚™) converges to xâ‚€ iff (vâ‚™) converges to xâ‚€.
-- Two ways to express the "eventually coincides" condition:
-- 1. `âˆ€á¶  n in atTop, u n = v n`
example (u v : â„• â†’ â„) (h : âˆ€á¶  n in atTop, u n = v n) (xâ‚€ : â„) :
    Tendsto u atTop (ğ“ xâ‚€) â†” Tendsto v atTop (ğ“ xâ‚€) :=
  tendsto_congr' h

-- 2. `u = á¶ [atTop] v` = `EventuallyEq atTop u v`
example (u v : â„• â†’ â„) (h : u =á¶ [atTop] v) (xâ‚€ : â„) :
    Tendsto u atTop (ğ“ xâ‚€) â†” Tendsto v atTop (ğ“ xâ‚€) :=
  tendsto_congr' h

-- Filter axioms can be interpreted with Eventually
-- Given filter F on X and predicates P, Q on X.

-- `univ âˆˆ F`
-- If
--   P(x) is true for all x in X,
-- then
--   eventually P(x) is true along F.
-- `(âˆ€ x âˆˆ X, P x) â†’ (âˆ€á¶  x in F, P x)`
#check Filter.Eventually.of_forall

-- `U âˆˆ F â†’ U âŠ† V â†’ V âˆˆ F`
-- If
--   P(x) is eventually true along F
--   P(x) implies Q(x) for all x in X,
-- then
--   eventually Q(x) is true along F.
-- `(âˆ€á¶  x in F, P x) â†’ (âˆ€ x âˆˆ X, P x â†’ Q x) â†’ (âˆ€á¶  x in F, Q x)`
#check Filter.Eventually.mono

-- `U âˆˆ F â†’ V âˆˆ F â†’ U âˆ© V âˆˆ F`
-- If
--   P(x) is eventually true along F
--   Q(x) is eventually true along F
-- then
--   P(x) âˆ§ Q(x) is eventually true along F
-- `(âˆ€á¶  x in F, P x) â†’ (âˆ€á¶  x in F, Q x) â†’ (âˆ€á¶  x in F, P x âˆ§ Q x)`
#check Filter.Eventually.and

-- If
--   P(n) is true for sufficiently large n
--   Q(n) is true for sufficiently large n
--   P(n) âˆ§ Q(n) implies R(n) for sufficiently large n
-- then
--   R(n) is true for sufficiently large n
example (P Q R : â„• â†’ Prop) (hP : âˆ€á¶  n in atTop, P n) (hQ : âˆ€á¶  n in atTop, Q n)
    (hR : âˆ€á¶  n in atTop, P n âˆ§ Q n â†’ R n) : âˆ€á¶  n in atTop, R n := by
  -- Show: R(n) is true for sufficiently large n.
  -- We have:
  --   Q(n) is true for sufficiently large n
  --   P(n) âˆ§ Q(n) implies R(n) for sufficiently large n
  -- Thus:
  --   Q(n) âˆ§ (P(n) âˆ§ Q(n) â†’ R(n)) is true for sufficiently large n.
  -- We also have:
  --   P(n) is true for sufficiently large n
  -- Thus:
  --   P(n) âˆ§ (Q(n) âˆ§ (P(n) âˆ§ Q(n) â†’ R(n))) is true for sufficiently large n.
  -- Now, if we have
  --   P(n) âˆ§ (Q(n) âˆ§ (P(n) âˆ§ Q(n) â†’ R(n))) â†’ R(n) is always true
  -- Then we will have what we need to show. Thus, we show the above.
  apply (hP.and (hQ.and hR)).mono
  -- Show: âˆ€ n âˆˆ â„•, P(n) âˆ§ (Q(n) âˆ§ (P(n) âˆ§ Q(n) â†’ R(n))) â†’ R(n) is true
  -- Fix n âˆˆ â„•. Suppose P(n), Q(n), P(n) âˆ§ Q(n) â†’ R(n) are true.
  -- Show: R(n) is true.
  rintro n âŸ¨h, h', h''âŸ©
  -- Since P(n) and Q(n) are true, P(n) âˆ§ Q(n) is true.
  -- Since P(n) âˆ§ Q(n) implies R(n), R(n) is true.
  exact h'' âŸ¨h, h'âŸ©

example (P Q R : â„• â†’ Prop) (hP : âˆ€á¶  n in atTop, P n) (hQ : âˆ€á¶  n in atTop, Q n)
    (hR : âˆ€á¶  n in atTop, P n âˆ§ Q n â†’ R n) : âˆ€á¶  n in atTop, R n := by
  -- Since
  --   P(n) is true for sufficiently large n
  --   Q(n) is true for sufficiently large n
  --   P(n) âˆ§ Q(n) implies R(n) for sufficiently large n
  -- there is a large enough n s.t. P(n), Q(n), P(n) âˆ§ Q(n) â†’ R(n) are true.
  -- Consider that n âˆˆ â„• as "large enough".
  -- If R(n) is true, then we can conclude
  -- that R(n) is true for sufficiently large n.
  filter_upwards [hP, hQ, hR] with n h h' h''
  exact h'' âŸ¨h, h'âŸ©

-- `âˆƒá¶  x in F, P x`:
--   means `{x | Â¬ P x} âˆ‰ F`
--     there is no "large" set where P is false
--     P(x) is infinitely often true along F
--   notation for `Filter.Frequently P F`
-- Ex: `âˆƒá¶  n in atTop, P n` means P(n) is true for infinitely many n
--   i.e., there are arbitrarily large n s.t. P(n) is true
example : (âˆƒá¶  n in atTop, n % 2 = 0) := Nat.frequently_mod_eq Nat.zero_lt_two

-- `ClusterPt x F` is defined as `(ğ“ x âŠ“ F).NeBot`
-- x is a cluster point of a filter F
-- neighborhoods of x intersected with F are non-empty
example {X : Type} [TopologicalSpace X] (x : X) (F : Filter X) :
  ClusterPt x F = (ğ“ x âŠ“ F).NeBot := rfl

#check mem_closure_iff_clusterPt
#check le_principal_iff
#check neBot_of_le

-- Given
--   a sequence (uâ‚™: â„• â†’ â„)
--   a set M âŠ† â„
--   a real number x
-- If
--   uâ‚™ converges to x as n â†’ âˆ
--   uâ‚™ is in M for sufficiently large n
-- Then
--   x is in the closure of M
example (u : â„• â†’ â„) (M : Set â„) (x : â„) (hux : Tendsto u atTop (ğ“ x))
    (huM : âˆ€á¶  n in atTop, u n âˆˆ M) : x âˆˆ closure M :=
  -- Short proof:
  -- mem_closure_iff_clusterPt.mpr (neBot_of_le (le_inf hux (le_principal_iff.mpr huM)))
  -- Long proof:
  by
  -- Show: x is in the closure of M.
  -- A point x is in the closure of M iff
  -- x is a cluster point of the principal filter of M.
  -- Show: x is a cluster point of the principal filter of M.
  apply mem_closure_iff_clusterPt.mpr
  -- By definition of cluster point,
  -- Show: ğ“ x âŠ“ ğ“Ÿ M is non-trivial
  rw [ClusterPt]
  -- Plan: Show that ğ“(x) âŠ“ ğ“Ÿ(M) is "larger" than a non-trivial filter.
  -- Show: u(`atTop`) â‰¤ ğ“(x) âŠ“ ğ“Ÿ(M).
  have : map u atTop â‰¤ ğ“ x âŠ“ ğ“Ÿ M := by
    -- Show: u(`atTop`) â‰¤ ğ“(x).
    have hâ‚ : map u atTop â‰¤ ğ“ x := by
      -- Since uâ‚™ converges to x, u(`atTop`) â‰¤ ğ“(x).
      rw [Tendsto] at hux
      -- Show: u(`atTop`) â‰¤ ğ“(x).
      exact hux
    -- Show: u(`atTop`) â‰¤ ğ“Ÿ(M).
    have hâ‚‚ : map u atTop â‰¤ ğ“Ÿ M := by
      -- Since uâ‚™ âˆˆ M for sufficiently large n, M âˆˆ u(`atTop`).
      have : M âˆˆ map u atTop := huM
      -- Then, u(`atTop`) â‰¤ ğ“Ÿ(M).
      exact le_principal_iff.mpr this
    exact le_inf hâ‚ hâ‚‚
  -- Since `atTop` is non-trivial, u(`atTop`) is non-trivial,
  -- and thus, ğ“ x âŠ“ ğ“Ÿ M is non-trivial.
  exact neBot_of_le this

-- Above is a special version of `mem_closure_of_tendsto`
-- where the topological space and the filter can be arbitrary.
#check mem_closure_of_tendsto
