import MIL.Common
import Mathlib.Topology.Instances.Real
import Mathlib.Analysis.Normed.Operator.BanachSteinhaus

open Set Filter
open Topology Filter

-- 10.2. Metric spaces

-- Let X be a metric space.
-- Let a, b, c be points in X.
variable {X : Type*} [MetricSpace X] (a b c : X)

-- A metric space is a set of points equipped with a metric.
-- The metric is way to measure the distance between two points.

-- `dist` is a function X¬≤ ‚Üí ‚Ñù.
-- Input: two points a and b in X
-- Output: the distance in ‚Ñù between a and b
#check (dist a b : ‚Ñù)

-- A metric is a distance function satisfies the following properties:
-- 1. Non-negativity: the distance between two points is always non-negative.
--      dist(a, b) ‚â• 0, ‚àÄ a, b ‚àà X
#check (dist_nonneg : 0 ‚â§ dist a b)
-- 2. The distance between two points is zero iff the points are the same.
--     dist(a, b) = 0 ‚Üî a = b, ‚àÄ a, b ‚àà X
#check (dist_eq_zero : dist a b = 0 ‚Üî a = b)
-- 3. Symmetry: the distance between two points is the same in both directions.
--     dist(a, b) = dist(b, a), ‚àÄ a, b ‚àà X
#check (dist_comm a b : dist a b = dist b a)
-- 4. The triangle inequality: the distance between two points is always ‚â§ to the sum of
--                             the distances between the points and a third point.
--     dist(a, c) ‚â§ dist(a, b) + dist(b, c), ‚àÄ a, b, c ‚àà X
#check (dist_triangle a b c : dist a c ‚â§ dist a b + dist b c)

-- Example:
-- 1. Real numbers ‚Ñù is a metric space with
--      dist(a, b) = |a - b| where |.| is the absolute value function.
-- 2. Euclidean space ‚Ñù‚Åø is a metric space with
--      dist(a, b) = ‚àö(‚àë·µ¢ (a·µ¢ - b·µ¢)¬≤) where a, b ‚àà ‚Ñù‚Åø

-- `EMetricSpace`: extended metric space
--   allows the distance to be infinite
#check EMetricSpace
-- `PseudoMetricSpace`: pseudo metric space
--   allows the distance between two distinct points to be zero
#check PseudoMetricSpace
-- `PseudoEMetricSpace`: pseudo extended metric space
--   (combining `EMetricSpace` and `PseudoMetricSpace`)
--   allows the distance between two points to be infinite
--   and the distance between two distinct points to be zero
#check PseudoEMetricSpace

-- 10.2.1. convergence and continuity in metric spaces

-- Metric spaces allow defining
--   convergence of sequences
--   continuity of functions between metric spaces
-- using the distance function.

-- Classic epsilon-N definition of convergence:
-- A sequence {u‚Çô} in a metric space converges to a point a iff
-- for every Œµ > 0, there exists an N such that
-- for all n ‚â• N, dist(u‚Çô, a) < Œµ.
example {u : ‚Ñï ‚Üí X} {a : X} :
    Tendsto u atTop (ùìù a) ‚Üî ‚àÄ Œµ > 0, ‚àÉ N, ‚àÄ n ‚â• N, dist (u n) a < Œµ :=
  Metric.tendsto_atTop

-- Classic epsilon-delta definition of continuity:
-- A function f between two metric spaces is continuous iff
-- for all x in X, for all Œµ > 0, there exists a Œ¥ > 0 such that
-- for all x' in X, if dist(x', x) < Œ¥, then dist(f(x'), f(x)) < Œµ.
example {X Y : Type*} [MetricSpace X] [MetricSpace Y] {f : X ‚Üí Y} :
    Continuous f ‚Üî
      ‚àÄ x : X, ‚àÄ Œµ > 0, ‚àÉ Œ¥ > 0, ‚àÄ x', dist x' x < Œ¥ ‚Üí dist (f x') (f x) < Œµ :=
  Metric.continuous_iff

-- The function that measures the distance between two points is continuous.
-- If X and Y are metric spaces, the Cartesian product X √ó Y is a metric space.
-- So, X¬≤ is a metric space.
-- ‚Ñù is a metric space.
-- The distance function goes between two metric spaces, so we can talk about continuity.
-- The distance function is continuous.
example {X : Type*} [MetricSpace X] : Continuous fun p : X √ó X ‚Ü¶ dist p.1 p.2 :=
  by continuity

-- Moreover, the function that measures the distance between
-- the images of points under a continuous function is also continuous.
-- i.e., if f is a continuous function from X to Y
-- then the function p ‚Ü¶ dist (f p.1) (f p.2) is also continuous.

-- Proof with the `continuity` tactic
example {X Y : Type*} [MetricSpace X] [MetricSpace Y] {f : X ‚Üí Y} (hf : Continuous f) :
    Continuous fun p : X √ó X ‚Ü¶ dist (f p.1) (f p.2) := by continuity

-- Proof with a proof term
-- `continuous_fst` and `continuous_snd`: projections are continuous
example {X : Type*} [MetricSpace X] : Continuous (Prod.fst : X √ó X ‚Üí X) := continuous_fst
example {X : Type*} [MetricSpace X] : Continuous (Prod.snd : X √ó X ‚Üí X) := continuous_snd
-- `Continuous.comp`: composition of continuous functions is continuous
example {X Y Z : Type*} [MetricSpace X] [MetricSpace Y] [MetricSpace Z]
        {f : X ‚Üí Y} {g : Y ‚Üí Z} (hf : Continuous f) (hg : Continuous g) :
    Continuous (g ‚àò f) := hg.comp hf
-- `Continuous.prod_mk`: pairing of continuous functions is continuous
--   If f, g are continuous then (f √ó g)(x) := (f(x), g(x)) is continuous.
example {X Y Z : Type*} [MetricSpace X] [MetricSpace Y] [MetricSpace Z]
        {f : X ‚Üí Y} {g : X ‚Üí Z} (hf : Continuous f) (hg : Continuous g) :
    Continuous (fun x : X ‚Ü¶ (f x, g x)) := Continuous.prod_mk hf hg
-- `Œª p ‚Ü¶ dist (f p.1) (f p.2)` = dist ‚àò ((f ‚àò `Prod.fst`) √ó (f ‚àò `Prod.snd`))
-- `apply Continuous.comp` will not recognize the definitionally equality
-- However, a full proof term works
example {X Y : Type*} [MetricSpace X] [MetricSpace Y] {f : X ‚Üí Y} (hf : Continuous f) :
    Continuous fun p : X √ó X ‚Ü¶ dist (f p.1) (f p.2) :=
  continuous_dist.comp ((hf.comp continuous_fst).prod_mk (hf.comp continuous_snd))

-- Proof with `Continuous.dist`:
--   If f, g are continuous functions, then x ‚Ü¶ dist(f(x), g(x)) is continuous.
--   `Continuous f ‚Üí Continuous g ‚Üí Continuous (fun x ‚Ü¶ dist (f x) (g x))`
-- Tactic mode:
example {X Y : Type*} [MetricSpace X] [MetricSpace Y] {f : X ‚Üí Y} (hf : Continuous f) :
    Continuous fun p : X √ó X ‚Ü¶ dist (f p.1) (f p.2) := by
  apply Continuous.dist
  exact hf.comp continuous_fst
  exact hf.comp continuous_snd
-- Term mode:
example {X Y : Type*} [MetricSpace X] [MetricSpace Y] {f : X ‚Üí Y} (hf : Continuous f) :
    Continuous fun p : X √ó X ‚Ü¶ dist (f p.1) (f p.2) :=
  (hf.comp continuous_fst).dist (hf.comp continuous_snd)

-- Proof with `Continuous.prodMap`:
-- `Continuous.prodMap`: If f, g are continuous functions,
--                       then (f √ó g)(p‚ÇÅ, p‚ÇÇ) := (f(p‚ÇÅ), g(p‚ÇÇ)) is continuous.
example {X Y Z : Type*} [MetricSpace X] [MetricSpace Y] [MetricSpace Z]
        {f : X ‚Üí Y} {g : X ‚Üí Z} (hf : Continuous f) (hg : Continuous g) :
    Continuous fun p : X √ó X ‚Ü¶ (f p.1, g p.2) := hf.prodMap hg
-- `Œª p ‚Ü¶ dist (f p.1) (f p.2)` = dist ‚àò (f √ó f)
example {X Y : Type*} [MetricSpace X] [MetricSpace Y] {f : X ‚Üí Y} (hf : Continuous f) :
    Continuous fun p : X √ó X ‚Ü¶ dist (f p.1) (f p.2) := continuous_dist.comp (hf.prodMap hf)

-- Proof with `Continuous.fst'` and `Continuous.snd'`:
-- `Continuous.fst'`: image of projection to the first coordinate is continuous
--   If f is continuous, then (f ‚àò `Prod.fst`) is continuous.
-- Similarly, `Continuous.snd'`: If f is continuous, then (f ‚àò `Prod.snd`) is continuous.
-- Problem: obfuscates the proof
example {X Y : Type*} [MetricSpace X] [MetricSpace Y] {f : X ‚Üí Y} (hf : Continuous f) :
    Continuous fun p : X √ó X ‚Ü¶ dist (f p.1) (f p.2) :=
  hf.fst'.dist hf.snd'

-- If f is continuous, then f(x¬≤ + x) is continuous.
-- `continuous_pow`: x ‚Ü¶ x‚Åø, denoted ‚¨ù‚Åø,  is continuous for all n ‚àà ‚Ñï
#check continuous_pow
-- `continuous_id`: x ‚Ü¶ x, denoted id, is continuous
#check continuous_id
-- `Œª x ‚Ü¶ f (x ^ 2 + x)` = f ‚àò (‚¨ù¬≤ + id)
example {f : ‚Ñù ‚Üí X} (hf : Continuous f) : Continuous fun x : ‚Ñù ‚Ü¶ f (x ^ 2 + x) :=
  hf.comp ((continuous_pow 2).add continuous_id)

-- A function f is continuous at a point a iff for every Œµ > 0,
-- there exists a Œ¥ > 0 s.t. for all x, if dist(x, a) < Œ¥, then dist(f(x), f(a)) < Œµ.
example {X Y : Type*} [MetricSpace X] [MetricSpace Y] (f : X ‚Üí Y) (a : X) :
    ContinuousAt f a ‚Üî ‚àÄ Œµ > 0, ‚àÉ Œ¥ > 0, ‚àÄ {x}, dist x a < Œ¥ ‚Üí dist (f x) (f a) < Œµ :=
  Metric.continuousAt_iff

-- A function is continuous iff it is continuous at every point.
example {X Y : Type*} [MetricSpace X] [MetricSpace Y] (f : X ‚Üí Y) :
    Continuous f ‚Üî ‚àÄ a, ContinuousAt f a := continuous_iff_continuousAt

-- 10.2.2. Balls, open sets and closed sets

-- Let r be a real number.
variable (r : ‚Ñù)

-- `Metric.ball a r`: the open ball centered at a with radius r
--   set of all points whose distance from a is strictly less than r
-- Example: an open ball in ‚Ñù is an open interval (a - r, a + r)
-- Example: an open ball in ‚Ñù¬≤ is a disk without its boundary circle
example : Metric.ball a r = { b | dist b a < r } :=
  rfl

-- `Metric.closedBall a r`: the closed ball centered at a with radius r
--   set of all points whose distance from a is less than or equal to r
-- Example: a closed ball in ‚Ñù is a closed interval [a - r, a + r]
-- Example: a closed ball in ‚Ñù¬≤ is a disk with its boundary circle
example : Metric.closedBall a r = { b | dist b a ‚â§ r } :=
  rfl

-- There is no sign restriction on the radius r.
-- If r is negative, any open or closed ball is empty.
-- If r is zero, any open ball is empty, and the closed ball is a singleton.

-- If r is positive, the center a is in the open ball.
example (hr : 0 < r) : a ‚àà Metric.ball a r :=
  Metric.mem_ball_self hr

-- If r is non-negative, the center a is in the closed ball.
example (hr : 0 ‚â§ r) : a ‚àà Metric.closedBall a r :=
  Metric.mem_closedBall_self hr

-- A set is open iff for every point in the set,
-- there exists an open ball centered at the point
-- that is entirely contained in the set.
-- Intuition: an open set doesn't include its boundary.
-- Intuition: every point has a wiggle room to move around without leaving the set.
-- Formally, a set s is open iff ‚àÄ x ‚àà s, ‚àÉ Œµ > 0, B(x, Œµ) ‚äÜ s.
example (s : Set X) : IsOpen s ‚Üî ‚àÄ x ‚àà s, ‚àÉ Œµ > 0, Metric.ball x Œµ ‚äÜ s :=
  Metric.isOpen_iff

-- Example: an open ball is an open set
example (a : X) (r : ‚Ñù) : IsOpen (Metric.ball a r) :=
  -- Simple Lean proof:
  -- Metric.isOpen_ball
  -- Long proof:
  by
  rw [Metric.isOpen_iff]
  -- Consider x ‚àà B(a, r).
  -- Show: there exists Œµ > 0 s.t. B(x, Œµ) ‚äÜ B(a, r).
  intro x hx
  -- Let Œµ = r - dist(x, a).
  use r - dist x a
  constructor
  ¬∑ -- Show Œµ > 0.
    -- As x ‚àà B(a, r), dist(x, a) < r. Thus, Œµ = r - dist(x, a) > 0.
    exact sub_pos.mpr hx
  ¬∑ -- Let y ‚àà B(x, Œµ).
    -- Show y ‚àà B(a, r).
    intro y hy
    -- As y ‚àà B(x, Œµ), dist(y, x) < Œµ = r - dist(x, a).
    -- Show dist(y, a) < r.
    rw [Metric.mem_ball] at *
    -- dist(y, a) ‚â§ dist(y, x) + dist(x, a) (‚àµ triangle inequality)
    --            < r - dist(x, a) + dist(x, a) (‚àµ dist(y, x) < r - dist(x, a))
    --            = r
    calc
      dist y a ‚â§ dist y x + dist x a := dist_triangle y x a
      _ < r - dist x a + dist x a := add_lt_add_right hy (dist x a)
      _ = r := sub_add_cancel r (dist x a)

-- A set is closed iff its complement is open.
-- Intuition: a closed set includes its boundary.
-- Intuition: a closed set contains all its limit points.
example {s : Set X} : IsClosed s ‚Üî IsOpen (s·∂ú) :=
  isOpen_compl_iff.symm

-- Example: a closed ball is a closed set
example (a : X) (r : ‚Ñù) : IsClosed (Metric.closedBall a r) := Metric.isClosed_ball

-- A closed set is closed under limits.

-- `mem_of_tendsto`: general version
--   if a function is *eventually* in a closed set
--   and converges to a point along a non-trivial filter,
--   then the limit point is in the closed set.

-- If a sequence is in a closed set and converges to a limit point,
-- then the limit point is also in the closed set.
-- Given
--   a set s
--   a point a
--   a sequence (u‚Çô)
-- If
--   s is closed
--   (u‚Çô) converges to a
--   ‚àÄ n ‚àà ‚Ñï, u‚Çô ‚àà s
-- Then
--   a ‚àà s
example {s : Set X} {a : X} {u : ‚Ñï ‚Üí X}
  (hs : IsClosed s) (hu : Tendsto u atTop (ùìù a)) (hus : ‚àÄ n, u n ‚àà s)
  : a ‚àà s :=
  -- `mem_of_tendsto` only needs eventually u‚Çô ‚àà s, not all u‚Çô ‚àà s
  hs.mem_of_tendsto hu (Eventually.of_forall hus)

-- The closure of a set is the smallest closed set that contains the set.
-- Intuition: the closure "fills in the gaps" in a set.
-- Notation: cl(s)

-- Interior point: ‚àÉ Œµ > 0, B(a, Œµ) ‚äÜ s.
-- Limit point: ‚àÄ Œµ > 0, B(a, Œµ) ‚à© s ‚â† ‚àÖ.
-- Boundary point: ‚àÄ Œµ > 0, B(a, Œµ) ‚à© s ‚â† ‚àÖ ‚àß B(a, Œµ) ‚à© s·∂ú ‚â† ‚àÖ.

-- A point a is in the closure of a set s iff
-- for every Œµ > 0, there exists a point b in s s.t. a ‚àà B(b, Œµ)
-- (or, equivalently, ‚àÄ Œµ > 0, B(a, Œµ) ‚à© s ‚â† ‚àÖ)
-- `mem_closure_iff`: a ‚àà closure s ‚Üî ‚àÄ Œµ > 0, ‚àÉ b ‚àà s, dist(a, b) < Œµ
-- Intuition: we can always find a point in s arbitrarily close to a.
-- Intuition: a is a limit point of s, so a is either in s or on the boundary of s.
example {a : X} {s : Set X} : a ‚àà closure s ‚Üî ‚àÄ Œµ > 0, ‚àÉ b ‚àà s, a ‚àà Metric.ball b Œµ :=
  Metric.mem_closure_iff

-- A point is in the closure of a set if
-- there is a sequence in the set that converges to the point.
-- Given
--  a point a
--  a sequence (u‚Çô)
--  a set s
-- If
--  (u‚Çô) converges to a
--  ‚àÄ n ‚àà ‚Ñï, u‚Çô ‚àà s
-- Then
--  a is in the closure of s
example {u : ‚Ñï ‚Üí X} {s : Set X} (hu : Tendsto u atTop (ùìù a)) (hs : ‚àÄ n, u n ‚àà s) :
    a ‚àà closure s :=
  by
  -- By definition of the closure of s,
  -- show ‚àÄ Œµ > 0, ‚àÉ b ‚àà s, dist(a, b) < Œµ.
  rw [Metric.mem_closure_iff]
  -- Let Œµ > 0. Show ‚àÉ b ‚àà s, dist(a, b) < Œµ.
  intro Œµ hŒµpos
  -- Since (u‚Çô) converges to a and Œµ > 0,
  -- ‚àÉ N ‚àà ‚Ñï, ‚àÄ n ‚â• N, dist(u‚Çô, a) < Œµ.
  rw [Metric.tendsto_atTop] at hu
  -- Fix such N ‚àà ‚Ñï. Then ‚àÄ n ‚â• N, dist(u‚Çô, a) < Œµ.
  rcases (hu Œµ hŒµpos) with ‚ü®N, h‚ü©
  -- Let b = u_N.
  -- Show b ‚àà s and dist(a, b) < Œµ.
  use u N
  constructor
  ¬∑ -- Show b ‚àà s.
    -- Since u‚Çô ‚àà s ‚àÄ n ‚àà ‚Ñï, b = u_N ‚àà s.
    exact hs N
  ¬∑ -- Show dist(a, b) < Œµ.
    -- Or, equivalently, show dist(u_N, a) < Œµ.
    rw [dist_comm]
    -- Since ‚àÄ n ‚â• N, dist(u‚Çô, a) < Œµ, dist(u_N, a) < Œµ.
    exact h N (le_refl N)

-- Open balls form a basis for the neighborhood filter.
#check Metric.nhds_basis_ball
-- All neighborhoods of a point contain an open ball centered at the point.
-- More formally, a set s is in the neighborhood filter of a point x iff
-- there is a positive radius Œµ s.t. the open ball centered at x with radius Œµ
-- is entirely contained in s.
-- i.e., s ‚àà ùìù x ‚Üî ‚àÉ Œµ > 0, B(x, Œµ) ‚äÜ s
example {x : X} {s : Set X} : s ‚àà ùìù x ‚Üî ‚àÉ Œµ > 0, Metric.ball x Œµ ‚äÜ s :=
  Metric.nhds_basis_ball.mem_iff

-- Closed balls also form a basis for the neighborhood filter.
#check Metric.nhds_basis_closedBall
-- A set s is in the neighborhood filter of a point x iff
-- there is a positive radius Œµ s.t. the closed ball centered at x with radius Œµ
-- is entirely contained in s.
example {x : X} {s : Set X} : s ‚àà ùìù x ‚Üî ‚àÉ Œµ > 0, Metric.closedBall x Œµ ‚äÜ s :=
  Metric.nhds_basis_closedBall.mem_iff

-- A function f is continuous at a point x iff
-- for every neighborhood V of f(x), there exists a neighborhood U of x
-- s.t. f(U) ‚äÜ V.
-- `mem_map_iff_exists_image`: U ‚àà f(F) ‚Üî ‚àÉ V ‚àà F, f(V) ‚äÜ U
example {X Y : Type*} [MetricSpace X] [MetricSpace Y] {f : X ‚Üí Y} {x : X} :
  ContinuousAt f x ‚Üî (‚àÄ V ‚àà ùìù (f x), ‚àÉ U ‚àà ùìù x, f '' U ‚äÜ V) := ‚ü®
    fun h _ hV => mem_map_iff_exists_image.mp (h hV),
    fun h' V hV => mem_map_iff_exists_image.mpr (h' V hV),
  ‚ü©

-- A function f is continuous at a point x iff
-- for every Œµ > 0, there exists a Œ¥ > 0 s.t.
-- f(B(x, Œ¥)) ‚äÜ B(f(x), Œµ).
example {X Y : Type*} [MetricSpace X] [MetricSpace Y] {f : X ‚Üí Y} {x : X} :
  ContinuousAt f x ‚Üî ‚àÄ Œµ > 0, ‚àÉ Œ¥ > 0, f '' Metric.ball x Œ¥ ‚äÜ Metric.ball (f x) Œµ :=
  by
  constructor
  ¬∑ -- Suppose f is continuous at x.
    -- Consider Œµ > 0.
    -- Show ‚àÉ Œ¥ > 0, f(B(x, Œ¥)) ‚äÜ B(f(x), Œµ).
    intro h Œµ hŒµpos
    -- By definition of continuity at x,
    -- we have f tends to f(x) as input tends to x.
    -- This means that for all neighborhood V of f(x),
    -- f‚Åª¬π(V) is a neighborhood of x.
    rw [ContinuousAt, tendsto_def] at h
    -- Since B(f(x), Œµ) is a neighborhood of f(x),
    -- f‚Åª¬π(B(f(x), Œµ)) is a neighborhood of x.
    have := h (Metric.ball (f x) Œµ) (Metric.ball_mem_nhds (f x) hŒµpos)
    -- By definition of a neighborhood of x,
    -- ‚àÉ Œ¥ > 0, B(x, Œ¥) ‚äÜ f‚Åª¬π(B(f(x), Œµ)).
    rw [Metric.mem_nhds_iff] at this
    -- Fix such Œ¥ > 0. Then, B(x, Œ¥) ‚äÜ f‚Åª¬π(B(f(x), Œµ)).
    -- Show f(B(x, Œ¥)) ‚äÜ B(f(x), Œµ).
    rcases this with ‚ü®Œ¥, hŒ¥pos, h‚ü©
    use Œ¥, hŒ¥pos
    -- Since image and preimage are a Galois connection,
    -- f(B(x, Œ¥)) ‚äÜ B(f(x), Œµ).
    exact image_subset_iff.mpr h
  ¬∑ -- Suppose ‚àÄ Œµ > 0, ‚àÉ Œ¥ > 0, f(B(x, Œ¥)) ‚äÜ B(f(x), Œµ).
    -- Show f is continuous at x.
    intro h
    -- Consider a neighborhood V of f(x).
    -- Show V ‚àà f(ùìù(x)).
    intro V hV
    -- Since V is a neighborhood of f(x),
    -- ‚àÉ Œµ > 0, B(f(x), Œµ) ‚äÜ V.
    rw [Metric.mem_nhds_iff] at hV
    -- Fix such Œµ > 0. Then B(f(x), Œµ) ‚äÜ V.
    rcases hV with ‚ü®Œµ, hŒµpos, h'‚ü©
    -- Since Œµ > 0, ‚àÉ Œ¥ > 0 s.t. f(B(x, Œ¥)) ‚äÜ B(f(x), Œµ).
    -- Fix such Œ¥ > 0. Then f(B(x, Œ¥)) ‚äÜ B(f(x), Œµ).
    rcases h Œµ hŒµpos with ‚ü®Œ¥, hŒ¥pos, h‚ü©
    -- We can show V ‚àà f(ùìù(x)) if
    -- we show f‚Åª¬π(V) is a neighborhood of x.
    apply mem_map.mpr
    -- This is equivalent to
    -- show ‚àÉ Œ¥ > 0, B(x, Œ¥) ‚äÜ f‚Åª¬π(V).
    rw [Metric.mem_nhds_iff]
    -- Let Œ¥ be the same as before.
    -- Show B(x, Œ¥) ‚äÜ f‚Åª¬π(V).
    use Œ¥, hŒ¥pos
    -- This is equivalent to
    -- Show f(B(x, Œ¥)) ‚äÜ V.
    apply image_subset_iff.mp
    -- Since f(B(x, Œ¥)) ‚äÜ B(f(x), Œµ) and B(f(x), Œµ) ‚äÜ V,
    -- f(B(x, Œ¥)) ‚äÜ V.
    intro _ hy
    exact h' (h hy)

-- 10.2.3. Compactness

-- Many properties of finite sets
-- can be extended to infinite sets that are "compact".

-- `IsCompact` is a typeclass for compact sets.
-- In Lean, compactness is defined using filters:
-- A set is compact if every non-trivial filter that contains the set
-- has a cluster point in the set.
-- A cluster point is a point whose neighborhoods intersects the filter non-trivially.
example {s : Set X} :
  IsCompact s = ‚àÄ F [NeBot F], F ‚â§ ùìü s ‚Üí ‚àÉ x ‚àà s, ClusterPt x F := rfl

-- The closed unit interval in ‚Ñù, [0, 1], is a closed set.
example : IsCompact (Set.Icc 0 1 : Set ‚Ñù) :=
  isCompact_Icc

-- Any sequence taking values in a compact set has
-- a subsequence that converges to a point in the set.
-- Intuition: No sequence can escape a compact set to infinity.
-- Relevant lemma: `IsCompact.tendsto_subseq`
-- Given
--   a set s
--   a sequence (u(n))
-- If
--   s is compact
--   ‚àÄ n ‚àà ‚Ñï, u(n) ‚àà s
-- Then:
--   there exists an a ‚àà s
--   there exists a subsequence indexed by œÜ : ‚Ñï ‚Üí ‚Ñï
--   such that œÜ is strictly increasing
--   and the subsequence ((u ‚àò œÜ)(n)) converges to a
example {s : Set X} (hs : IsCompact s) {u : ‚Ñï ‚Üí X} (hu : ‚àÄ n, u n ‚àà s) :
    ‚àÉ a ‚àà s, ‚àÉ œÜ : ‚Ñï ‚Üí ‚Ñï, StrictMono œÜ ‚àß Tendsto (u ‚àò œÜ) atTop (ùìù a) :=
  hs.tendsto_subseq hu

-- Extreme value theorem:
-- Any continuous function on a non-empty compact set with values in ‚Ñù
-- is bounded and attains its bounds somewhere.
-- Relevant lemma: `IsCompact.exists_isMinOn` and `IsCompact.exists_isMaxOn`
-- Given
--   a set s
--   a function f : X ‚Üí ‚Ñù
-- If
--   s is compact and non-empty
--   f is continuous on s
-- Then:
--   there exists a point x ‚àà s s.t. ‚àÄ y ‚àà s, f(x) ‚â§ f(y)
example {s : Set X} (hs : IsCompact s) (hs' : s.Nonempty) {f : X ‚Üí ‚Ñù}
      (hfs : ContinuousOn f s) :
    ‚àÉ x ‚àà s, ‚àÄ y ‚àà s, f x ‚â§ f y :=
  hs.exists_isMinOn hs' hfs
-- Same as above but for the maximum.
example {s : Set X} (hs : IsCompact s) (hs' : s.Nonempty) {f : X ‚Üí ‚Ñù}
      (hfs : ContinuousOn f s) :
    ‚àÉ x ‚àà s, ‚àÄ y ‚àà s, f y ‚â§ f x :=
  hs.exists_isMaxOn hs' hfs

-- Compact sets are closed.
-- Relevant lemma: `IsCompact.isClosed`
example {s : Set X} (hs : IsCompact s) : IsClosed s :=
  hs.isClosed

-- A metric space is compact if the entire space is compact.
-- In Lean, `CompactSpace` is a typeclass for compact spaces.

-- In a compact space, the universe set is compact.
example {X : Type*} [MetricSpace X] [CompactSpace X] : IsCompact (univ : Set X) :=
  isCompact_univ

-- In a compact space, any closed set is compact.
#check IsClosed.isCompact

example {X : Type*} [MetricSpace X] {Y : Type*} [MetricSpace Y] {f : X ‚Üí Y} :
    UniformContinuous f ‚Üî
      ‚àÄ Œµ > 0, ‚àÉ Œ¥ > 0, ‚àÄ {a b : X}, dist a b < Œ¥ ‚Üí dist (f a) (f b) < Œµ :=
  Metric.uniformContinuous_iff

example {X : Type*} [MetricSpace X] [CompactSpace X]
      {Y : Type*} [MetricSpace Y] {f : X ‚Üí Y}
    (hf : Continuous f) : UniformContinuous f :=
  by
  rw [Metric.uniformContinuous_iff]
  intro Œµ hŒµpos
  let œÜ : X √ó X ‚Üí ‚Ñù := fun p ‚Ü¶ dist (f p.1) (f p.2)
  let K := { p : X √ó X | Œµ ‚â§ œÜ p }
  have hœÜ : Continuous œÜ := hf.fst'.dist hf.snd'
  have hK : IsCompact K := (isClosed_le continuous_const hœÜ).isCompact
  rcases eq_empty_or_nonempty K with (hKemp | hKnemp)
  ¬∑ use 1
    constructor
    ¬∑ exact zero_lt_one
    ¬∑ intro a b _
      contrapose! hKemp
      use (a, b)
      rw [mem_setOf]
      exact hKemp
  ¬∑ rcases hK.exists_isMinOn hKnemp continuous_dist.continuousOn with ‚ü®x, hxK, hxinf‚ü©
    use dist x.1 x.2
    constructor
    ¬∑ apply dist_pos.mpr
      intro h
      have : Œµ ‚â§ 0 := by
        calc
          Œµ ‚â§ œÜ x := hxK
          _ = dist (f x.1) (f x.2) := by dsimp [œÜ]
          _ = dist (f x.1) (f x.1) := by rw [‚Üê h]
          _ = 0 := by apply dist_eq_zero.mpr; rfl
      linarith
    ¬∑ intro a b h
      contrapose! h
      rw [isMinOn_iff] at hxinf
      exact hxinf (a, b) h


example (u : ‚Ñï ‚Üí X) :
    CauchySeq u ‚Üî ‚àÄ Œµ > 0, ‚àÉ N : ‚Ñï, ‚àÄ m ‚â• N, ‚àÄ n ‚â• N, dist (u m) (u n) < Œµ :=
  Metric.cauchySeq_iff

example (u : ‚Ñï ‚Üí X) :
    CauchySeq u ‚Üî ‚àÄ Œµ > 0, ‚àÉ N : ‚Ñï, ‚àÄ n ‚â• N, dist (u n) (u N) < Œµ :=
  Metric.cauchySeq_iff'

example [CompleteSpace X] (u : ‚Ñï ‚Üí X) (hu : CauchySeq u) :
    ‚àÉ x, Tendsto u atTop (ùìù x) :=
  cauchySeq_tendsto_of_complete hu

open BigOperators

open Finset

theorem cauchySeq_of_le_geometric_two' {u : ‚Ñï ‚Üí X}
    (hu : ‚àÄ n : ‚Ñï, dist (u n) (u (n + 1)) ‚â§ (1 / 2) ^ n) : CauchySeq u := by
  rw [Metric.cauchySeq_iff']
  intro Œµ Œµ_pos
  obtain ‚ü®N, hN‚ü© : ‚àÉ N : ‚Ñï, 1 / 2 ^ N * 2 < Œµ := by
    have : Tendsto (fun n : ‚Ñï ‚Ü¶ (1 / 2 ^ n : ‚Ñù)) atTop (ùìù 0) := by
      simp_rw [‚Üê one_div_pow]
      apply tendsto_pow_atTop_nhds_zero_of_lt_one (by linarith) (by linarith)
    rw [Metric.tendsto_atTop] at this
    rcases this (Œµ / 2) (half_pos Œµ_pos) with ‚ü®N, hN‚ü©
    have := hN N (le_refl N)
    use N
    rw [Real.dist_0_eq_abs] at this
    have h : 0 ‚â§ 1 / (2 : ‚Ñù) ^ N := by
      rw [‚Üê one_div_pow]
      apply pow_nonneg
      simp only [one_div, inv_nonneg, Nat.ofNat_nonneg]
    rw [abs_of_nonneg h] at this
    linarith only [this]
  use N
  intro n hn
  obtain ‚ü®k, rfl : n = N + k‚ü© := le_iff_exists_add.mp hn
  calc
    dist (u (N + k)) (u N) = dist (u (N + 0)) (u (N + k)) := by
      rw [dist_comm]
      rw [add_zero N]
    _ ‚â§ ‚àë i in range k, dist (u (N + i)) (u (N + (i + 1))) :=
      dist_le_range_sum_dist (fun i => u (N + i)) k
    _ ‚â§ ‚àë i in range k, (1 / 2 : ‚Ñù) ^ (N + i) :=
      sum_le_sum fun i _ => hu (N + i)
    _ = 1 / 2 ^ N * ‚àë i in range k, (1 / 2 : ‚Ñù) ^ i := by
      simp_rw [‚Üê one_div_pow, pow_add, mul_sum]
    _ ‚â§ 1 / 2 ^ N * 2 := by
      apply mul_le_mul
      ¬∑ apply le_refl
      ¬∑ exact sum_geometric_two_le k
      ¬∑ apply sum_nonneg
        intro _ _
        apply pow_nonneg
        simp
      ¬∑ rw [‚Üê one_div_pow]
        apply pow_nonneg
        simp
    _ < Œµ := hN


open Metric

example [CompleteSpace X] (f : ‚Ñï ‚Üí Set X) (ho : ‚àÄ n, IsOpen (f n)) (hd : ‚àÄ n, Dense (f n)) :
    Dense (‚ãÇ n, f n) := by
  let B : ‚Ñï ‚Üí ‚Ñù := fun n ‚Ü¶ (1 / 2) ^ n
  have Bpos : ‚àÄ n, 0 < B n := fun n => pow_pos (by simp) n
  /- Translate the density assumption into two functions `center` and `radius` associating
    to any n, x, Œ¥, Œ¥pos a center and a positive radius such that
    `closedBall center radius` is included both in `f n` and in `closedBall x Œ¥`.
    We can also require `radius ‚â§ (1/2)^(n+1)`, to ensure we get a Cauchy sequence later. -/
  have :
    ‚àÄ (n : ‚Ñï) (x : X),
      ‚àÄ Œ¥ > 0, ‚àÉ y : X, ‚àÉ r > 0, r ‚â§ B (n + 1) ‚àß closedBall y r ‚äÜ closedBall x Œ¥ ‚à© f n :=
    by
    intro n x Œ¥ hŒ¥pos
    have hdn := hd n
    rw [dense_iff] at hdn
    rcases hdn x (Œ¥ / 2) (half_pos hŒ¥pos) with ‚ü®y, hyb, hyfn‚ü©
    have hon := ho n
    rw [Metric.isOpen_iff] at hon
    rcases hon y hyfn with ‚ü®Œµ, hŒµpos, hbyŒµfn‚ü©
    let Œµ' := min (min (Œ¥ / 2) (B (n + 1))) (Œµ / 2)
    have hŒµ'B : Œµ' ‚â§ Œ¥ / 2 := le_trans (min_le_left _ _) (min_le_left _ _)
    have hŒµ'Œµ : Œµ' < Œµ := by
      have : Œµ' ‚â§ (Œµ / 2) := min_le_right _ _
      apply lt_of_le_of_lt this
      linarith [hŒµpos]
    use y, Œµ'
    constructor
    ¬∑ exact lt_min (lt_min (half_pos hŒ¥pos) (Bpos (n + 1))) (half_pos hŒµpos)
    ¬∑ constructor
      ¬∑ exact le_trans (min_le_left _ _) (min_le_right _ _)
      ¬∑ intro z hz
        constructor
        ¬∑ rw [mem_closedBall] at *
          rw [mem_ball] at hyb
          calc
            dist z x ‚â§ dist z y + dist y x := dist_triangle z y x
            _ ‚â§ Œ¥ / 2 + Œ¥ / 2 := add_le_add (le_trans hz hŒµ'B) (le_of_lt hyb)
            _ = Œ¥ := by ring
        ¬∑ apply hbyŒµfn
          rw [mem_closedBall] at hz
          rw [mem_ball]
          exact lt_of_le_of_lt hz hŒµ'Œµ
  choose! center radius Hpos HB Hball using this
  intro x
  rw [mem_closure_iff_nhds_basis nhds_basis_closedBall]
  intro Œµ Œµpos
  /- `Œµ` is positive. We have to find a point in the ball of radius `Œµ` around `x`
    belonging to all `f n`. For this, we construct inductively a sequence
    `F n = (c n, r n)` such that the closed ball `closedBall (c n) (r n)` is included
    in the previous ball and in `f n`, and such that `r n` is small enough to ensure
    that `c n` is a Cauchy sequence. Then `c n` converges to a limit which belongs
    to all the `f n`. -/
  let F : ‚Ñï ‚Üí X √ó ‚Ñù := fun n ‚Ü¶
    Nat.recOn n (Prod.mk x (min Œµ (B 0)))
      fun n p ‚Ü¶ Prod.mk (center n p.1 p.2) (radius n p.1 p.2)
  let c : ‚Ñï ‚Üí X := fun n ‚Ü¶ (F n).1
  let r : ‚Ñï ‚Üí ‚Ñù := fun n ‚Ü¶ (F n).2
  have rpos : ‚àÄ n, 0 < r n := by
    intro n
    induction' n with n hn
    ¬∑ dsimp [r, F]
      exact lt_min Œµpos (Bpos 0)
    ¬∑ exact Hpos n (c n) (r n) hn
  have rB : ‚àÄ n, r n ‚â§ B n := by
    intro n
    induction' n with n hn
    ¬∑ dsimp [r, F, B]
      exact min_le_right _ _
    ¬∑ exact HB n (c n) (r n) (rpos n)
  have incl : ‚àÄ n, closedBall (c (n + 1)) (r (n + 1)) ‚äÜ closedBall (c n) (r n) ‚à© f n := by
    intro n
    exact Hball n (c n) (r n) (rpos n)
  have cdist : ‚àÄ n, dist (c n) (c (n + 1)) ‚â§ B n := by
    intro n
    have := (rpos (n + 1) |> le_of_lt |> mem_closedBall_self |> incl n).left
    rw [mem_closedBall'] at this
    exact le_trans this (rB n)
  have : CauchySeq c := cauchySeq_of_le_geometric_two' cdist
  -- as the sequence `c n` is Cauchy in a complete space, it converges to a limit `y`.
  rcases cauchySeq_tendsto_of_complete this with ‚ü®y, ylim‚ü©
  -- this point `y` will be the desired point. We will check that it belongs to all
  -- `f n` and to `ball x Œµ`.
  use y
  have I : ‚àÄ n, ‚àÄ m ‚â• n, closedBall (c m) (r m) ‚äÜ closedBall (c n) (r n) := by
    intro n
    apply Nat.le_induction
    ¬∑ exact subset_refl _
    ¬∑ intro m _ hss
      exact (incl m).trans (Set.inter_subset_left.trans hss)
  have yball : ‚àÄ n, y ‚àà closedBall (c n) (r n) := by
    intro n
    apply isClosed_ball.mem_of_tendsto ylim
    apply (eventually_ge_atTop n).mono
    intro m hnm
    exact rpos m |> le_of_lt |> mem_closedBall_self |> I n m hnm
  constructor
  ¬∑ rw [mem_iInter]
    intro n
    exact ((n + 1) |> yball |> incl n).right
  ¬∑ rw [mem_closedBall]
    have := yball 0
    rw [mem_closedBall] at this
    dsimp [c, r, F] at this
    exact le_trans this (min_le_left _ _)
