import MIL.Common
import Mathlib.Topology.Instances.Real
import Mathlib.Analysis.Normed.Operator.BanachSteinhaus

open Set Filter
open Topology Filter

-- 10.2. Metric spaces

-- Let X be a metric space.
-- Let a, b, c be points in X.
variable {X : Type*} [MetricSpace X] (a b c : X)

-- A metric space is a set of points equipped with a metric.
-- The metric is way to measure the distance between two points.

-- `dist` is a function X¬≤ ‚Üí ‚Ñù.
-- Input: two points a and b in X
-- Output: the distance in ‚Ñù between a and b
#check (dist a b : ‚Ñù)

-- A metric is a distance function satisfies the following properties:
-- 1. Non-negativity: the distance between two points is always non-negative.
--      dist(a, b) ‚â• 0, ‚àÄ a, b ‚àà X
#check (dist_nonneg : 0 ‚â§ dist a b)
-- 2. The distance between two points is zero iff the points are the same.
--     dist(a, b) = 0 ‚Üî a = b, ‚àÄ a, b ‚àà X
#check (dist_eq_zero : dist a b = 0 ‚Üî a = b)
-- 3. Symmetry: the distance between two points is the same in both directions.
--     dist(a, b) = dist(b, a), ‚àÄ a, b ‚àà X
#check (dist_comm a b : dist a b = dist b a)
-- 4. The triangle inequality: the distance between two points is always ‚â§ to the sum of
--                             the distances between the points and a third point.
--     dist(a, c) ‚â§ dist(a, b) + dist(b, c), ‚àÄ a, b, c ‚àà X
#check (dist_triangle a b c : dist a c ‚â§ dist a b + dist b c)

-- Example:
-- 1. Real numbers ‚Ñù is a metric space with
--      dist(a, b) = |a - b| where |.| is the absolute value function.
-- 2. Euclidean space ‚Ñù‚Åø is a metric space with
--      dist(a, b) = ‚àö(‚àë·µ¢ (a·µ¢ - b·µ¢)¬≤) where a, b ‚àà ‚Ñù‚Åø

-- `EMetricSpace`: extended metric space
--   allows the distance to be infinite
#check EMetricSpace
-- `PseudoMetricSpace`: pseudo metric space
--   allows the distance between two distinct points to be zero
#check PseudoMetricSpace
-- `PseudoEMetricSpace`: pseudo extended metric space
--   (combining `EMetricSpace` and `PseudoMetricSpace`)
--   allows the distance between two points to be infinite
--   and the distance between two distinct points to be zero
#check PseudoEMetricSpace

-- 10.2.1. convergence and continuity in metric spaces

-- Metric spaces allow defining
--   convergence of sequences
--   continuity of functions between metric spaces
-- using the distance function.

-- Classic epsilon-N definition of convergence:
-- A sequence {u‚Çô} in a metric space converges to a point a iff
-- for every Œµ > 0, there exists an N such that
-- for all n ‚â• N, dist(u‚Çô, a) < Œµ.
example {u : ‚Ñï ‚Üí X} {a : X} :
    Tendsto u atTop (ùìù a) ‚Üî ‚àÄ Œµ > 0, ‚àÉ N, ‚àÄ n ‚â• N, dist (u n) a < Œµ :=
  Metric.tendsto_atTop

-- Classic epsilon-delta definition of continuity:
-- A function f between two metric spaces is continuous iff
-- for all x in X, for all Œµ > 0, there exists a Œ¥ > 0 such that
-- for all x' in X, if dist(x', x) < Œ¥, then dist(f(x'), f(x)) < Œµ.
example {X Y : Type*} [MetricSpace X] [MetricSpace Y] {f : X ‚Üí Y} :
    Continuous f ‚Üî
      ‚àÄ x : X, ‚àÄ Œµ > 0, ‚àÉ Œ¥ > 0, ‚àÄ x', dist x' x < Œ¥ ‚Üí dist (f x') (f x) < Œµ :=
  Metric.continuous_iff

-- The function that measures the distance between two points is continuous.
-- If X and Y are metric spaces, the Cartesian product X √ó Y is a metric space.
-- So, X¬≤ is a metric space.
-- ‚Ñù is a metric space.
-- The distance function goes between two metric spaces, so we can talk about continuity.
-- The distance function is continuous.
example {X : Type*} [MetricSpace X] : Continuous fun p : X √ó X ‚Ü¶ dist p.1 p.2 :=
  by continuity

-- Moreover, the function that measures the distance between
-- the images of points under a continuous function is also continuous.
-- i.e., if f is a continuous function from X to Y
-- then the function p ‚Ü¶ dist (f p.1) (f p.2) is also continuous.

-- Proof with the `continuity` tactic
example {X Y : Type*} [MetricSpace X] [MetricSpace Y] {f : X ‚Üí Y} (hf : Continuous f) :
    Continuous fun p : X √ó X ‚Ü¶ dist (f p.1) (f p.2) := by continuity

-- Proof with a proof term
-- `continuous_fst` and `continuous_snd`: projections are continuous
example {X : Type*} [MetricSpace X] : Continuous (Prod.fst : X √ó X ‚Üí X) := continuous_fst
example {X : Type*} [MetricSpace X] : Continuous (Prod.snd : X √ó X ‚Üí X) := continuous_snd
-- `Continuous.comp`: composition of continuous functions is continuous
example {X Y Z : Type*} [MetricSpace X] [MetricSpace Y] [MetricSpace Z]
        {f : X ‚Üí Y} {g : Y ‚Üí Z} (hf : Continuous f) (hg : Continuous g) :
    Continuous (g ‚àò f) := hg.comp hf
-- `Continuous.prod_mk`: pairing of continuous functions is continuous
--   If f, g are continuous then (f √ó g)(x) := (f(x), g(x)) is continuous.
example {X Y Z : Type*} [MetricSpace X] [MetricSpace Y] [MetricSpace Z]
        {f : X ‚Üí Y} {g : X ‚Üí Z} (hf : Continuous f) (hg : Continuous g) :
    Continuous (fun x : X ‚Ü¶ (f x, g x)) := Continuous.prod_mk hf hg
-- `Œª p ‚Ü¶ dist (f p.1) (f p.2)` = dist ‚àò ((f ‚àò `Prod.fst`) √ó (f ‚àò `Prod.snd`))
-- `apply Continuous.comp` will not recognize the definitionally equality
-- However, a full proof term works
example {X Y : Type*} [MetricSpace X] [MetricSpace Y] {f : X ‚Üí Y} (hf : Continuous f) :
    Continuous fun p : X √ó X ‚Ü¶ dist (f p.1) (f p.2) :=
  continuous_dist.comp ((hf.comp continuous_fst).prod_mk (hf.comp continuous_snd))

-- Proof with `Continuous.dist`:
--   If f, g are continuous functions, then x ‚Ü¶ dist(f(x), g(x)) is continuous.
--   `Continuous f ‚Üí Continuous g ‚Üí Continuous (fun x ‚Ü¶ dist (f x) (g x))`
-- Tactic mode:
example {X Y : Type*} [MetricSpace X] [MetricSpace Y] {f : X ‚Üí Y} (hf : Continuous f) :
    Continuous fun p : X √ó X ‚Ü¶ dist (f p.1) (f p.2) := by
  apply Continuous.dist
  exact hf.comp continuous_fst
  exact hf.comp continuous_snd
-- Term mode:
example {X Y : Type*} [MetricSpace X] [MetricSpace Y] {f : X ‚Üí Y} (hf : Continuous f) :
    Continuous fun p : X √ó X ‚Ü¶ dist (f p.1) (f p.2) :=
  (hf.comp continuous_fst).dist (hf.comp continuous_snd)

-- Proof with `Continuous.prodMap`:
-- `Continuous.prodMap`: If f, g are continuous functions,
--                       then (f √ó g)(p‚ÇÅ, p‚ÇÇ) := (f(p‚ÇÅ), g(p‚ÇÇ)) is continuous.
example {X Y Z : Type*} [MetricSpace X] [MetricSpace Y] [MetricSpace Z]
        {f : X ‚Üí Y} {g : X ‚Üí Z} (hf : Continuous f) (hg : Continuous g) :
    Continuous fun p : X √ó X ‚Ü¶ (f p.1, g p.2) := hf.prodMap hg
-- `Œª p ‚Ü¶ dist (f p.1) (f p.2)` = dist ‚àò (f √ó f)
example {X Y : Type*} [MetricSpace X] [MetricSpace Y] {f : X ‚Üí Y} (hf : Continuous f) :
    Continuous fun p : X √ó X ‚Ü¶ dist (f p.1) (f p.2) := continuous_dist.comp (hf.prodMap hf)

-- Proof with `Continuous.fst'` and `Continuous.snd'`:
-- `Continuous.fst'`: image of projection to the first coordinate is continuous
--   If f is continuous, then (f ‚àò `Prod.fst`) is continuous.
-- Similarly, `Continuous.snd'`: If f is continuous, then (f ‚àò `Prod.snd`) is continuous.
-- Problem: obfuscates the proof
example {X Y : Type*} [MetricSpace X] [MetricSpace Y] {f : X ‚Üí Y} (hf : Continuous f) :
    Continuous fun p : X √ó X ‚Ü¶ dist (f p.1) (f p.2) :=
  hf.fst'.dist hf.snd'

-- If f is continuous, then f(x¬≤ + x) is continuous.
-- `continuous_pow`: x ‚Ü¶ x‚Åø, denoted ‚¨ù‚Åø,  is continuous for all n ‚àà ‚Ñï
#check continuous_pow
-- `continuous_id`: x ‚Ü¶ x, denoted id, is continuous
#check continuous_id
-- `Œª x ‚Ü¶ f (x ^ 2 + x)` = f ‚àò (‚¨ù¬≤ + id)
example {f : ‚Ñù ‚Üí X} (hf : Continuous f) : Continuous fun x : ‚Ñù ‚Ü¶ f (x ^ 2 + x) :=
  hf.comp ((continuous_pow 2).add continuous_id)

-- A function f is continuous at a point a iff for every Œµ > 0,
-- there exists a Œ¥ > 0 s.t. for all x, if dist(x, a) < Œ¥, then dist(f(x), f(a)) < Œµ.
example {X Y : Type*} [MetricSpace X] [MetricSpace Y] (f : X ‚Üí Y) (a : X) :
    ContinuousAt f a ‚Üî ‚àÄ Œµ > 0, ‚àÉ Œ¥ > 0, ‚àÄ {x}, dist x a < Œ¥ ‚Üí dist (f x) (f a) < Œµ :=
  Metric.continuousAt_iff

-- A function is continuous iff it is continuous at every point.
example {X Y : Type*} [MetricSpace X] [MetricSpace Y] (f : X ‚Üí Y) :
    Continuous f ‚Üî ‚àÄ a, ContinuousAt f a := continuous_iff_continuousAt

-- 10.2.2. Balls, open sets and closed sets

-- Let r be a real number.
variable (r : ‚Ñù)

-- `Metric.ball a r`: the open ball centered at a with radius r
--   set of all points whose distance from a is strictly less than r
-- Example: an open ball in ‚Ñù is an open interval (a - r, a + r)
-- Example: an open ball in ‚Ñù¬≤ is a disk without its boundary circle
example : Metric.ball a r = { b | dist b a < r } :=
  rfl

-- `Metric.closedBall a r`: the closed ball centered at a with radius r
--   set of all points whose distance from a is less than or equal to r
-- Example: a closed ball in ‚Ñù is a closed interval [a - r, a + r]
-- Example: a closed ball in ‚Ñù¬≤ is a disk with its boundary circle
example : Metric.closedBall a r = { b | dist b a ‚â§ r } :=
  rfl

-- There is no sign restriction on the radius r.
-- If r is negative, any open or closed ball is empty.
-- If r is zero, any open ball is empty, and the closed ball is a singleton.

-- If r is positive, the center a is in the open ball.
example (hr : 0 < r) : a ‚àà Metric.ball a r :=
  Metric.mem_ball_self hr

-- If r is non-negative, the center a is in the closed ball.
example (hr : 0 ‚â§ r) : a ‚àà Metric.closedBall a r :=
  Metric.mem_closedBall_self hr

-- A set is open iff for every point in the set,
-- there exists an open ball centered at the point
-- that is entirely contained in the set.
-- Intuition: an open set doesn't include its boundary.
-- Intuition: every point has a wiggle room to move around without leaving the set.
-- Formally, a set s is open iff ‚àÄ x ‚àà s, ‚àÉ Œµ > 0, B(x, Œµ) ‚äÜ s.
example (s : Set X) : IsOpen s ‚Üî ‚àÄ x ‚àà s, ‚àÉ Œµ > 0, Metric.ball x Œµ ‚äÜ s :=
  Metric.isOpen_iff

-- Example: an open ball is an open set
example (a : X) (r : ‚Ñù) : IsOpen (Metric.ball a r) :=
  -- Simple Lean proof:
  -- Metric.isOpen_ball
  -- Long proof:
  by
  rw [Metric.isOpen_iff]
  -- Consider x ‚àà B(a, r).
  -- Show: there exists Œµ > 0 s.t. B(x, Œµ) ‚äÜ B(a, r).
  intro x hx
  -- Let Œµ = r - dist(x, a).
  use r - dist x a
  constructor
  ¬∑ -- Show Œµ > 0.
    -- As x ‚àà B(a, r), dist(x, a) < r. Thus, Œµ = r - dist(x, a) > 0.
    exact sub_pos.mpr hx
  ¬∑ -- Let y ‚àà B(x, Œµ).
    -- Show y ‚àà B(a, r).
    intro y hy
    -- As y ‚àà B(x, Œµ), dist(y, x) < Œµ = r - dist(x, a).
    -- Show dist(y, a) < r.
    rw [Metric.mem_ball] at *
    -- dist(y, a) ‚â§ dist(y, x) + dist(x, a) (‚àµ triangle inequality)
    --            < r - dist(x, a) + dist(x, a) (‚àµ dist(y, x) < r - dist(x, a))
    --            = r
    calc
      dist y a ‚â§ dist y x + dist x a := dist_triangle y x a
      _ < r - dist x a + dist x a := add_lt_add_right hy (dist x a)
      _ = r := sub_add_cancel r (dist x a)

-- A set is closed iff its complement is open.
-- Intuition: a closed set includes its boundary.
-- Intuition: a closed set contains all its limit points.
example {s : Set X} : IsClosed s ‚Üî IsOpen (s·∂ú) :=
  isOpen_compl_iff.symm

-- Example: a closed ball is a closed set
example (a : X) (r : ‚Ñù) : IsClosed (Metric.closedBall a r) := Metric.isClosed_ball

-- A closed set is closed under limits.

-- `mem_of_tendsto`: general version
--   if a function is *eventually* in a closed set
--   and converges to a point along a non-trivial filter,
--   then the limit point is in the closed set.

-- If a sequence is in a closed set and converges to a limit point,
-- then the limit point is also in the closed set.
-- Given
--   a set s
--   a point a
--   a sequence (u‚Çô)
-- If
--   s is closed
--   (u‚Çô) converges to a
--   ‚àÄ n ‚àà ‚Ñï, u‚Çô ‚àà s
-- Then
--   a ‚àà s
example {s : Set X} {a : X} {u : ‚Ñï ‚Üí X}
  (hs : IsClosed s) (hu : Tendsto u atTop (ùìù a)) (hus : ‚àÄ n, u n ‚àà s)
  : a ‚àà s :=
  -- `mem_of_tendsto` only needs eventually u‚Çô ‚àà s, not all u‚Çô ‚àà s
  hs.mem_of_tendsto hu (Eventually.of_forall hus)

-- The closure of a set is the smallest closed set that contains the set.
-- Intuition: the closure "fills in the gaps" in a set.
-- Notation: cl(s)

-- Interior point: ‚àÉ Œµ > 0, B(a, Œµ) ‚äÜ s.
-- Limit point: ‚àÄ Œµ > 0, B(a, Œµ) ‚à© s ‚â† ‚àÖ.
-- Boundary point: ‚àÄ Œµ > 0, B(a, Œµ) ‚à© s ‚â† ‚àÖ ‚àß B(a, Œµ) ‚à© s·∂ú ‚â† ‚àÖ.

-- A point a is in the closure of a set s iff
-- for every Œµ > 0, there exists a point b in s s.t. a ‚àà B(b, Œµ)
-- (or, equivalently, ‚àÄ Œµ > 0, B(a, Œµ) ‚à© s ‚â† ‚àÖ)
-- `mem_closure_iff`: a ‚àà closure s ‚Üî ‚àÄ Œµ > 0, ‚àÉ b ‚àà s, dist(a, b) < Œµ
-- Intuition: we can always find a point in s arbitrarily close to a.
-- Intuition: a is a limit point of s, so a is either in s or on the boundary of s.
example {a : X} {s : Set X} : a ‚àà closure s ‚Üî ‚àÄ Œµ > 0, ‚àÉ b ‚àà s, a ‚àà Metric.ball b Œµ :=
  Metric.mem_closure_iff

-- A point is in the closure of a set if
-- there is a sequence in the set that converges to the point.
-- Given
--  a point a
--  a sequence (u‚Çô)
--  a set s
-- If
--  (u‚Çô) converges to a
--  ‚àÄ n ‚àà ‚Ñï, u‚Çô ‚àà s
-- Then
--  a is in the closure of s
example {u : ‚Ñï ‚Üí X} {s : Set X} (hu : Tendsto u atTop (ùìù a)) (hs : ‚àÄ n, u n ‚àà s) :
    a ‚àà closure s :=
  by
  -- By definition of the closure of s,
  -- show ‚àÄ Œµ > 0, ‚àÉ b ‚àà s, dist(a, b) < Œµ.
  rw [Metric.mem_closure_iff]
  -- Let Œµ > 0. Show ‚àÉ b ‚àà s, dist(a, b) < Œµ.
  intro Œµ hŒµpos
  -- Since (u‚Çô) converges to a and Œµ > 0,
  -- ‚àÉ N ‚àà ‚Ñï, ‚àÄ n ‚â• N, dist(u‚Çô, a) < Œµ.
  rw [Metric.tendsto_atTop] at hu
  -- Fix such N ‚àà ‚Ñï. Then ‚àÄ n ‚â• N, dist(u‚Çô, a) < Œµ.
  rcases (hu Œµ hŒµpos) with ‚ü®N, h‚ü©
  -- Let b = u_N.
  -- Show b ‚àà s and dist(a, b) < Œµ.
  use u N
  constructor
  ¬∑ -- Show b ‚àà s.
    -- Since u‚Çô ‚àà s ‚àÄ n ‚àà ‚Ñï, b = u_N ‚àà s.
    exact hs N
  ¬∑ -- Show dist(a, b) < Œµ.
    -- Or, equivalently, show dist(u_N, a) < Œµ.
    rw [dist_comm]
    -- Since ‚àÄ n ‚â• N, dist(u‚Çô, a) < Œµ, dist(u_N, a) < Œµ.
    exact h N (le_refl N)

-- Open balls form a basis for the neighborhood filter.
#check Metric.nhds_basis_ball
-- All neighborhoods of a point contain an open ball centered at the point.
-- More formally, a set s is in the neighborhood filter of a point x iff
-- there is a positive radius Œµ s.t. the open ball centered at x with radius Œµ
-- is entirely contained in s.
-- i.e., s ‚àà ùìù x ‚Üî ‚àÉ Œµ > 0, B(x, Œµ) ‚äÜ s
example {x : X} {s : Set X} : s ‚àà ùìù x ‚Üî ‚àÉ Œµ > 0, Metric.ball x Œµ ‚äÜ s :=
  Metric.nhds_basis_ball.mem_iff

-- Closed balls also form a basis for the neighborhood filter.
#check Metric.nhds_basis_closedBall
-- A set s is in the neighborhood filter of a point x iff
-- there is a positive radius Œµ s.t. the closed ball centered at x with radius Œµ
-- is entirely contained in s.
example {x : X} {s : Set X} : s ‚àà ùìù x ‚Üî ‚àÉ Œµ > 0, Metric.closedBall x Œµ ‚äÜ s :=
  Metric.nhds_basis_closedBall.mem_iff

-- A function f is continuous at a point x iff
-- for every neighborhood V of f(x), there exists a neighborhood U of x
-- s.t. f(U) ‚äÜ V.
-- `mem_map_iff_exists_image`: U ‚àà f(F) ‚Üî ‚àÉ V ‚àà F, f(V) ‚äÜ U
example {X Y : Type*} [MetricSpace X] [MetricSpace Y] {f : X ‚Üí Y} {x : X} :
  ContinuousAt f x ‚Üî (‚àÄ V ‚àà ùìù (f x), ‚àÉ U ‚àà ùìù x, f '' U ‚äÜ V) := ‚ü®
    fun h _ hV => mem_map_iff_exists_image.mp (h hV),
    fun h' V hV => mem_map_iff_exists_image.mpr (h' V hV),
  ‚ü©

-- A function f is continuous at a point x iff
-- for every Œµ > 0, there exists a Œ¥ > 0 s.t.
-- f(B(x, Œ¥)) ‚äÜ B(f(x), Œµ).
-- This is essentially the epsilon-delta definition of continuity.
example {X Y : Type*} [MetricSpace X] [MetricSpace Y] {f : X ‚Üí Y} {x : X} :
  ContinuousAt f x ‚Üî ‚àÄ Œµ > 0, ‚àÉ Œ¥ > 0, f '' Metric.ball x Œ¥ ‚äÜ Metric.ball (f x) Œµ :=
  by
  -- By the epsilon-delta definition of continuity,
  -- f is continuous at x iff ‚àÄ Œµ > 0, ‚àÉ Œ¥ > 0 s.t.
  -- ‚àÄ x' ‚àà X, dist(x', x) < Œ¥ ‚Üí dist(f(x'), f(x)) < Œµ.
  rw [Metric.continuousAt_iff]
  constructor
  ¬∑ -- Suppose ‚àÄ Œµ > 0, ‚àÉ Œ¥ > 0, ‚àÄ x' ‚àà X, dist(x', x) < Œ¥ ‚Üí dist(f(x'), f(x)) < Œµ.
    -- Show ‚àÄ Œµ > 0, ‚àÉ Œ¥ > 0, f(B(x, Œ¥)) ‚äÜ B(f(x), Œµ).
    intro h
    -- Let Œµ > 0.
    -- Show ‚àÉ Œ¥ > 0, f(B(x, Œ¥)) ‚äÜ B(f(x), Œµ).
    intro Œµ hŒµpos
    -- By the hypothesis, ‚àÉ Œ¥ > 0 s.t. ‚àÄ x' ‚àà X, dist(x', x) < Œ¥ ‚Üí dist(f(x'), f(x)) < Œµ.
    -- Fix such Œ¥ > 0. Then, ‚àÄ x' ‚àà X, dist(x', x) < Œ¥ ‚Üí dist(f(x'), f(x)) < Œµ.
    rcases h Œµ hŒµpos with ‚ü®Œ¥, hŒ¥pos, h‚ü©
    -- Use Œ¥ > 0.
    -- Show f(B(x, Œ¥)) ‚äÜ B(f(x), Œµ).
    use Œ¥, hŒ¥pos
    -- Let y ‚àà f(B(x, Œ¥)).
    -- Show y ‚àà B(f(x), Œµ).
    intro y hy
    -- Since y ‚àà f(B(x, Œ¥)), ‚àÉ x' ‚àà B(x, Œ¥) s.t. y = f(x').
    -- Fix such x'. Then, dist(x', x) < Œ¥ and y = f(x').
    rcases hy with ‚ü®x', hx', rfl‚ü©
    -- Then, dist(y, f(x)) = dist(f(x'), f(x)) < Œµ.
    -- Or, equivalently, y ‚àà B(f(x), Œµ).
    exact h hx'
  ¬∑ -- Suppose ‚àÄ Œµ > 0, ‚àÉ Œ¥ > 0, f(B(x, Œ¥)) ‚äÜ B(f(x), Œµ).
    -- Show ‚àÄ Œµ > 0, ‚àÉ Œ¥ > 0, ‚àÄ x' ‚àà X, dist(x', x) < Œ¥ ‚Üí dist(f(x'), f(x)) < Œµ.
    intro h
    -- Let Œµ > 0.
    -- Show ‚àÉ Œ¥ > 0, ‚àÄ x' ‚àà X, dist(x', x) < Œ¥ ‚Üí dist(f(x'), f(x)) < Œµ.
    intro Œµ hŒµpos
    -- By the hypothesis, ‚àÉ Œ¥ > 0 s.t. f(B(x, Œ¥)) ‚äÜ B(f(x), Œµ).
    -- Fix such Œ¥ > 0. Then, f(B(x, Œ¥)) ‚äÜ B(f(x), Œµ).
    rcases h Œµ hŒµpos with ‚ü®Œ¥, hŒ¥pos, h‚ü©
    -- Use Œ¥ > 0.
    -- Show ‚àÄ x' ‚àà X, dist(x', x) < Œ¥ ‚Üí dist(f(x'), f(x)) < Œµ.
    use Œ¥, hŒ¥pos
    -- Let x' ‚àà X. Suppose dist(x', x) < Œ¥.
    -- Show dist(f(x'), f(x)) < Œµ.
    intro x' hx'
    -- Since dist(x', x) < Œ¥, x' ‚àà B(x, Œ¥). Then, f(x') ‚àà f(B(x, Œ¥)).
    have : f x' ‚àà f '' Metric.ball x Œ¥ := mem_image_of_mem f hx'
    -- Then, since f(B(x, Œ¥)) ‚äÜ B(f(x), Œµ), f(x') ‚àà B(f(x), Œµ).
    -- Or, equivalently, dist(f(x'), f(x)) < Œµ.
    exact h this

-- 10.2.3. Compactness

-- Many properties of finite sets
-- can be extended to infinite sets that are "compact".

-- `IsCompact` is a typeclass for compact sets.
-- In Lean, compactness is defined using filters:
-- A set is compact if every non-trivial filter that contains the set
-- has a cluster point in the set.
-- A cluster point is a point whose neighborhoods intersects the filter non-trivially.
example {s : Set X} :
  IsCompact s = ‚àÄ F [NeBot F], F ‚â§ ùìü s ‚Üí ‚àÉ x ‚àà s, ClusterPt x F := rfl

-- The closed unit interval in ‚Ñù, [0, 1], is a closed set.
example : IsCompact (Set.Icc 0 1 : Set ‚Ñù) :=
  isCompact_Icc

-- Any sequence taking values in a compact set has
-- a subsequence that converges to a point in the set.
-- Intuition: No sequence can escape a compact set to infinity.
-- Relevant lemma: `IsCompact.tendsto_subseq`
-- Given
--   a set s
--   a sequence (u(n))
-- If
--   s is compact
--   ‚àÄ n ‚àà ‚Ñï, u(n) ‚àà s
-- Then:
--   there exists an a ‚àà s
--   there exists a subsequence indexed by œÜ : ‚Ñï ‚Üí ‚Ñï
--   such that œÜ is strictly increasing
--   and the subsequence ((u ‚àò œÜ)(n)) converges to a
example {s : Set X} (hs : IsCompact s) {u : ‚Ñï ‚Üí X} (hu : ‚àÄ n, u n ‚àà s) :
    ‚àÉ a ‚àà s, ‚àÉ œÜ : ‚Ñï ‚Üí ‚Ñï, StrictMono œÜ ‚àß Tendsto (u ‚àò œÜ) atTop (ùìù a) :=
  hs.tendsto_subseq hu

-- Extreme value theorem:
-- Any continuous function on a non-empty compact set with values in ‚Ñù
-- is bounded and attains its bounds somewhere.
-- Relevant lemma: `IsCompact.exists_isMinOn` and `IsCompact.exists_isMaxOn`
-- Given
--   a set s
--   a function f : X ‚Üí ‚Ñù
-- If
--   s is compact and non-empty
--   f is continuous on s
-- Then:
--   there exists a point x ‚àà s s.t. ‚àÄ y ‚àà s, f(x) ‚â§ f(y)
example {s : Set X} (hs : IsCompact s) (hs' : s.Nonempty) {f : X ‚Üí ‚Ñù}
      (hfs : ContinuousOn f s) :
    ‚àÉ x ‚àà s, ‚àÄ y ‚àà s, f x ‚â§ f y :=
  hs.exists_isMinOn hs' hfs
-- Same as above but for the maximum.
example {s : Set X} (hs : IsCompact s) (hs' : s.Nonempty) {f : X ‚Üí ‚Ñù}
      (hfs : ContinuousOn f s) :
    ‚àÉ x ‚àà s, ‚àÄ y ‚àà s, f y ‚â§ f x :=
  hs.exists_isMaxOn hs' hfs

-- Compact sets are closed.
-- Relevant lemma: `IsCompact.isClosed`
example {s : Set X} (hs : IsCompact s) : IsClosed s :=
  hs.isClosed

-- A metric space is compact if the entire space is compact.
-- In Lean, `CompactSpace` is a typeclass for compact spaces.

-- In a compact space, the universe set is compact.
example {X : Type*} [MetricSpace X] [CompactSpace X] : IsCompact (univ : Set X) :=
  isCompact_univ

-- In a compact space, any closed set is compact.
#check IsClosed.isCompact

-- 10.2.4. Uniformly continuous functions

-- Uniform continuity requires a single Œ¥ to work for all points.
-- Continuity:
--   ‚àÄ x ‚àà X, ‚àÄ Œµ > 0, ‚àÉ Œ¥ > 0, ‚àÄ x' ‚àà X, dist(x', x) < Œ¥ ‚Üí dist(f(x'), f(x)) < Œµ.
-- Uniform continuity:
--   ‚àÄ Œµ > 0, ‚àÉ Œ¥ > 0, ‚àÄ x, x' ‚àà X, dist(x', x) < Œ¥ ‚Üí dist(f(x'), f(x)) < Œµ.
example {X : Type*} [MetricSpace X] {Y : Type*} [MetricSpace Y] {f : X ‚Üí Y} :
    UniformContinuous f ‚Üî
      ‚àÄ Œµ > 0, ‚àÉ Œ¥ > 0, ‚àÄ {a b : X}, dist a b < Œ¥ ‚Üí dist (f a) (f b) < Œµ :=
  Metric.uniformContinuous_iff

-- Example: f(x) = ax + b (a ‚â† 0) is uniformly continuous on ‚Ñù.
-- Proof:
-- Fix Œµ > 0.
-- Let Œ¥ = Œµ / |a|. Then, Œ¥ > 0.
-- Suppose for all x, x' ‚àà ‚Ñù, |x' - x| < Œ¥.
-- Then, |f(x') - f(x)| = |a(x' - x)| = |a||x' - x| < |a|Œ¥ = Œµ.
example {a b : ‚Ñù} (ha : a ‚â† 0) : UniformContinuous fun x : ‚Ñù ‚Ü¶ a * x + b :=
  by
  rw [Metric.uniformContinuous_iff]
  intro Œµ hŒµpos
  let Œ¥ := Œµ / abs a
  have hŒ¥pos : Œ¥ > 0 := div_pos hŒµpos (abs_pos.mpr ha)
  use Œ¥, hŒ¥pos
  intro x x' hx
  calc
    dist (a * x + b) (a * x' + b) = ‚Äña * x + b - (a * x' + b)‚Äñ := rfl
    _ = ‚Äña * x - a * x'‚Äñ := by rw [add_tsub_add_eq_tsub_right]
    _ = ‚Äña * (x - x')‚Äñ := by rw [mul_sub]
    _ = abs a * ‚Äñx - x'‚Äñ := IsAbsoluteValue.abv_mul norm a (x - x')
    _ = abs a * dist x x' := rfl
    _ < abs a * Œ¥ := mul_lt_mul_of_pos_left hx (abs_pos.mpr ha)
    _ = abs a * (Œµ / abs a) := rfl
    _ = Œµ := mul_div_cancel‚ÇÄ Œµ (abs_ne_zero.mpr ha)

-- Example: f(x) = ‚àöx is uniformly continuous on [0, ‚àû).
-- Proof:
-- Fix Œµ > 0.
-- Let Œ¥ = Œµ¬≤. Then, Œ¥ > 0.
-- Suppose ‚àÄ x, x' ‚àà [0, ‚àû), |x' - x| < Œ¥.
-- First, |‚àöx' - ‚àöx| ‚â§ |‚àöx'| + |‚àöx| = ‚àöx' + ‚àöx ‚â§ |‚àöx' + ‚àöx|
-- Then, |‚àöx' - ‚àöx|¬≤ ‚â§ |‚àöx' - ‚àöx| * |‚àöx' + ‚àöx| = |x' - x| < Œ¥ = Œµ¬≤.
-- So, |‚àöx' - ‚àöx| < Œµ.
example : UniformContinuousOn (fun x : ‚Ñù ‚Ü¶ ‚àöx) (Ici (0 : ‚Ñù)) :=
  by
  rw [Metric.uniformContinuousOn_iff]
  intro Œµ hŒµpos
  let Œ¥ := Œµ ^ 2
  have hŒ¥pos : Œ¥ > 0 := pow_pos hŒµpos 2
  use Œ¥, hŒ¥pos
  intro x hx x' hx' h
  have := calc
    (dist (‚àöx) (‚àöx')) ^ 2 = |‚àöx - ‚àöx'| ^ 2 := rfl
    _ ‚â§ |‚àöx - ‚àöx'| * |‚àöx + ‚àöx'| := by
      rw [sq]
      apply mul_le_mul_of_nonneg_left
      ¬∑ calc
          |‚àöx - ‚àöx'| = |‚àöx - 0 + 0 - ‚àöx'| := by rw [add_zero, sub_zero]
          _ = |(‚àöx - 0) + (0 - ‚àöx')| := by rw [add_sub_assoc]
          _ ‚â§ |‚àöx - 0| + |0 - ‚àöx'| := by exact abs_add_le (‚àöx - 0) (0 - ‚àöx')
          _ = |‚àöx| + |‚àöx'| := by rw [sub_zero, zero_sub, abs_neg]
          _ = ‚àöx + ‚àöx' := by rw [abs_of_nonneg (Real.sqrt_nonneg x), abs_of_nonneg (Real.sqrt_nonneg x')]
          _ ‚â§ |‚àöx + ‚àöx'| := le_abs_self (‚àöx + ‚àöx')
      ¬∑ exact abs_nonneg (‚àöx - ‚àöx')
    _ = |(‚àöx - ‚àöx') * (‚àöx + ‚àöx')| := Eq.symm (abs_mul (‚àöx - ‚àöx') (‚àöx + ‚àöx'))
    _ = |‚àöx ^ 2 - ‚àöx' ^ 2| := by rw [pow_two_sub_pow_two, mul_comm]
    _ ‚â§ |x - x'| := by
      rw [sq, sq]
      rw [‚Üê Real.sqrt_mul hx]
      rw [‚Üê Real.sqrt_mul hx']
      rw [‚Üê sq, ‚Üêsq]
      rw [Real.sqrt_sq_eq_abs, Real.sqrt_sq_eq_abs]
      rw [abs_eq_self.mpr hx, abs_eq_self.mpr hx']
    _ < Œ¥ := h
    _ = Œµ ^ 2 := rfl
  rw [‚Üê abs_eq_self.mpr dist_nonneg, ‚Üê abs_eq_self.mpr (le_of_lt hŒµpos)]
  exact sq_lt_sq.mp this

-- Example: f(x) = x¬≤ is not uniformly continuous on ‚Ñù.
-- Proof:
-- Suppose f is uniformly continuous for a proof by contradiction.
-- Then, for Œµ = 1, ‚àÉ Œ¥ > 0 s.t. ‚àÄ x, x' ‚àà ‚Ñù, |x' - x| < Œ¥ ‚Üí |x'¬≤ - x¬≤| < 1.
-- Let x = 2 / Œ¥ and x' = 2 / Œ¥ + Œ¥ / 2.
-- Then, |x' - x| = Œ¥ / 2 < Œ¥. So, |x'¬≤ - x¬≤| < 1.
-- However, |x'¬≤ - x¬≤| = 1 + (1 + Œ¥¬≤ / 4) ‚â• 1.
-- This is the contradiction.
example : ¬¨ UniformContinuous (fun x : ‚Ñù ‚Ü¶ x ^ 2) :=
  by
  by_contra h
  rw [Metric.uniformContinuous_iff] at h
  rcases h 1 zero_lt_one with ‚ü®Œ¥, hŒ¥pos, h‚ü©
  let x := 2 / Œ¥
  let x' := 2 / Œ¥ + Œ¥ / 2
  have hdx'x := by
    calc
      x' - x = 2 / Œ¥ + Œ¥ / 2 - 2 / Œ¥ := rfl
      _ = Œ¥ / 2 := by rw [sub_eq_iff_eq_add']
  have hxx' : dist x x' < Œ¥ := by
    calc
      dist x x' = abs (x - x') := rfl
      _ = abs (Œ¥ / 2) := by rw [abs_sub_comm x x', hdx'x]
      _ = Œ¥ / 2 := abs_of_nonneg (le_of_lt (half_pos hŒ¥pos))
      _ < Œ¥ := half_lt_self hŒ¥pos
  have hdxx'Œ¥ := h hxx'
  have : dist (x ^ 2) (x' ^ 2) ‚â• 1 := by
    have hax'x := by
      calc
        x' + x = 2 / Œ¥ + Œ¥ / 2 + 2 / Œ¥ := rfl
        _ = 4 / Œ¥ + Œ¥ / 2 := by ring
    have hdx'xpos : x' - x > 0 := by rw [hdx'x]; exact half_pos hŒ¥pos
    have hax'xpos : x' + x > 0 := by rw [hax'x]; exact add_pos (div_pos zero_lt_four hŒ¥pos) (half_pos hŒ¥pos)
    have had : (x' + x) * (x' - x) = 2 + Œ¥ ^ 2 / 4 := by
      calc
        (x' + x) * (x' - x) = (4 / Œ¥ + Œ¥ / 2) * (Œ¥ / 2) := by rw [hax'x, hdx'x]
        _ = ((4 / Œ¥) * (Œ¥ / 2) + (Œ¥ / 2) * (Œ¥ / 2)) := by ring
        _ = 2 + Œ¥ ^ 2 / 4 := by
          have : (4 / Œ¥) * (Œ¥ / 2) = 2 := by
            calc
              (4 / Œ¥) * (Œ¥ / 2) = 4 * ((1 / 2) * (Œ¥ / Œ¥)) := by ring
              _ = 4 * ((1 / 2) * 1) := by rw [div_self (ne_of_gt hŒ¥pos)]
              _ = 2 := by ring
          rw [this]
          have : (Œ¥ / 2) * (Œ¥ / 2) = Œ¥ ^ 2 / 4 := by ring
          rw [this]
    calc
      dist (x ^ 2) (x' ^ 2) = abs (x ^ 2 - x' ^ 2) := rfl
      _ = abs (x' ^ 2 - x ^ 2) := abs_sub_comm (x ^ 2) (x' ^ 2)
      _ = abs ((x' + x) * (x' - x)) := by rw [pow_two_sub_pow_two]
      _ = abs (x' + x) * abs (x' - x) := IsAbsoluteValue.abv_mul norm (x' + x) (x' - x)
      _ = (x' + x) * (x' - x) := by rw [abs_of_nonneg (le_of_lt hdx'xpos), abs_of_nonneg (le_of_lt hax'xpos)]
      _ = 2 + Œ¥ ^ 2 / 4 := by rw [had]
      _ = 1 + (1 + Œ¥ ^ 2 / 4) := by ring
      _ ‚â• 1 := by
        have : 1 + Œ¥ ^ 2 / 4 ‚â• 0 := add_nonneg zero_le_one (div_nonneg (pow_two_nonneg Œ¥) zero_le_four)
        exact le_add_of_nonneg_right this
  exact not_le_of_gt hdxx'Œ¥ this

-- A continuous function from a compact metric space
-- to a metric space is uniformly continuous.
-- Given:
--   metric spaces X and Y
--   function f : X ‚Üí Y
-- If:
--   X is compact
--   f is continuous
-- Then:
--   f is uniformly continuous
example {X : Type*} [MetricSpace X] [CompactSpace X]
      {Y : Type*} [MetricSpace Y] {f : X ‚Üí Y}
    (hf : Continuous f) : UniformContinuous f :=
  by
  -- By the definition of uniform continuity,
  -- show ‚àÄ Œµ > 0, ‚àÉ Œ¥ > 0, ‚àÄ x, x' ‚àà X, dist(x', x) < Œ¥ ‚Üí dist(f(x'), f(x)) < Œµ.
  rw [Metric.uniformContinuous_iff]
  -- Let Œµ > 0.
  -- Show ‚àÉ Œ¥ > 0, ‚àÄ x, x' ‚àà X, dist(x', x) < Œ¥ ‚Üí dist(f(x'), f(x)) < Œµ.
  intro Œµ hŒµpos
  -- Let œÜ : X √ó X ‚Üí ‚Ñù s.t. œÜ(x, x') = dist(f(x), f(x')).
  let œÜ : X √ó X ‚Üí ‚Ñù := fun p ‚Ü¶ dist (f p.1) (f p.2)
  -- From before, œÜ is continuous.
  have hœÜ : Continuous œÜ := hf.fst'.dist hf.snd'
  -- Let K = { (x, x') ‚àà X √ó X | Œµ ‚â§ œÜ(x, x') }.
  let K := { p : X √ó X | Œµ ‚â§ œÜ p }
  -- Since X is compact, X √ó X is compact.
  -- Since œÜ is continuous and Œµ is a constant function, which is continuous,
  -- K is closed. Hence, K is compact since X √ó X is compact.
  have hK : IsCompact K := (isClosed_le continuous_const hœÜ).isCompact
  -- K is either empty or non-empty.
  rcases eq_empty_or_nonempty K with (hKemp | hKnemp)
  ¬∑ -- Suppose K is empty.
    -- Use Œ¥ = 1.
    use 1
    -- Show Œ¥ > 0 and ‚àÄ x, x' ‚àà X, dist(x', x) < Œ¥ ‚Üí œÜ(x', x) < Œµ.
    constructor
    ¬∑ -- Œ¥ = 1 > 0.
      exact zero_lt_one
    ¬∑ -- Let x, x' ‚àà X. Suppose dist(x', x) < Œ¥ = 1.
      -- Show œÜ(x', x) < Œµ.
      intro x x' _
      -- Suppose œÜ(x', x) ‚â• Œµ for a proof by contradiction.
      by_contra! h
      -- Then, (x, x') ‚àà K.
      have : (x, x') ‚àà K := h
      -- Since K is empty, this is a contradiction.
      rw [hKemp] at this
      exact this
  ¬∑ -- Suppose K is non-empty.
    -- Using the Extreme Value Theorem, there exists
    -- a minimum (x, x') ‚àà K of œÜ.
    rcases hK.exists_isMinOn hKnemp continuous_dist.continuousOn with ‚ü®‚ü®x, x'‚ü©, hxK, hxinf‚ü©
    -- Let Œ¥ = dist(x, x').
    use dist x x'
    -- Show Œ¥ > 0 and ‚àÄ a, b ‚àà X, dist(a, b) < Œ¥ ‚Üí œÜ(a, b) < Œµ.
    constructor
    ¬∑ -- Show Œ¥ > 0.
      -- Since Œ¥ = dist(x, x'), show x ‚â† x'.
      apply dist_pos.mpr
      -- Suppose x = x' for a proof by contradiction.
      intro h
      -- Œµ ‚â§ œÜ(x, x') (‚àµ (x, x') ‚àà K)
      --   = dist(f(x), f(x')) = dist(f(x), f(x)) = 0.
      have : Œµ ‚â§ 0 := by
        calc
          Œµ ‚â§ œÜ (x, x') := hxK
          _ = dist (f x) (f x') := rfl
          _ = dist (f x) (f x) := by rw [h]
          _ = 0 := dist_self (f x)
      -- Since Œµ > 0, this is a contradiction.
      exact not_le_of_gt hŒµpos this
    ¬∑ -- Show ‚àÄ a, b ‚àà X, dist(a, b) < Œ¥ ‚Üí œÜ(a, b) < Œµ.
      -- Let a, b ‚àà X. Suppose dist(a, b) < Œ¥.
      -- Show œÜ(a, b) < Œµ.
      intro a b h
      -- Suppose œÜ(a, b) ‚â• Œµ for a proof by contradiction.
      by_contra! h'
      -- Then, (a, b) ‚àà K.
      have : (a, b) ‚àà K := h'
      -- Since we know that (x, x') is the minimum of œÜ,
      -- dist(a, b) ‚â• œÜ(x, x') = Œ¥.
      rw [isMinOn_iff] at hxinf
      have : dist a b ‚â• dist x x' := hxinf (a, b) this
      -- Since dist(a, b) < Œ¥, this is a contradiction.
      exact not_le_of_gt h this

-- 10.2.5. Completeness

-- A Cauchy sequence is a sequence where terms get arbitrarily close to each other.

-- A sequence is Cauchy iff for every Œµ > 0, there exists an N s.t.
-- for all m, n ‚â• N, dist(u‚Çò, u‚Çô) < Œµ.
--   ‚àÄ Œµ > 0, ‚àÉ N ‚àà ‚Ñï, ‚àÄ m, n ‚â• N, dist(u‚Çò, u‚Çô) < Œµ
example (u : ‚Ñï ‚Üí X) :
    CauchySeq u ‚Üî ‚àÄ Œµ > 0, ‚àÉ N : ‚Ñï, ‚àÄ m ‚â• N, ‚àÄ n ‚â• N, dist (u m) (u n) < Œµ :=
  Metric.cauchySeq_iff

-- A sequence is Cauchy iff for every Œµ > 0, there exists an N s.t.
-- for all n ‚â• N, dist(u‚Çô, u_N) < Œµ.
--   ‚àÄ Œµ > 0, ‚àÉ N ‚àà ‚Ñï, ‚àÄ n ‚â• N, dist(u‚Çô, u_N) < Œµ
example (u : ‚Ñï ‚Üí X) :
    CauchySeq u ‚Üî ‚àÄ Œµ > 0, ‚àÉ N : ‚Ñï, ‚àÄ n ‚â• N, dist (u n) (u N) < Œµ :=
  Metric.cauchySeq_iff'

-- Convergent sequences (with limit in the space) are Cauchy.
-- Intuition: If a sequence converges to a point in the space,
--            then the terms get arbitrarily close to the limit,
--            and hence to each other.
example [MetricSpace X] {u : ‚Ñï ‚Üí X} {a : X} (hu : Tendsto u atTop (ùìù a)) : CauchySeq u :=
  Tendsto.cauchySeq hu

-- The converse is not true in general.
-- Example: The sequence (u‚Çô) where u‚Çô = 1 / n in ‚Ñù \ {0}
--          is Cauchy but does not converge in ‚Ñù \ {0}.

-- A space is complete if every Cauchy sequence converges to a point *in the space*.
-- Intuition: the space has no "holes" or "gaps".
-- Example: ‚Ñù with the usual metric is complete.
example : CompleteSpace ‚Ñù := Real.instCompleteSpace

-- In a complete space, every Cauchy sequence converges to a point in the space.
-- Given:
--   metric space X
--   sequence (u‚Çô)
-- If:
--   X is complete
--   (u‚Çô) is Cauchy
-- Then:
--   there exists a limit x s.t. u‚Çô converges to x.
example [CompleteSpace X] (u : ‚Ñï ‚Üí X) (hu : CauchySeq u) :
    ‚àÉ (x : X), Tendsto u atTop (ùìù x) :=
  cauchySeq_tendsto_of_complete hu

-- Compact metric spaces are complete.
example [CompactSpace X] : CompleteSpace X := complete_of_compact

open BigOperators

open Finset

-- A sequence (u‚Çô) s.t. ‚àÄ n ‚àà ‚Ñï, dist(u‚Çô, u‚Çô‚Çä‚ÇÅ) ‚â§ (1 / 2)‚Åø is Cauchy.
-- Proof sketch:
--   1. Consider arbitrarily small Œµ > 0.
--   2. Show that there is an N s.t. 1 / 2 ^ N * 2 < Œµ.
--   3. dist(u_N, u_{N+k}) ‚â§ ‚àë_{n=N..N+k-1} dist(u‚Çô, u_{n+1})
--                         ‚â§ ‚àë_{i=0..k-1} (1 / 2) ^ {N + i}
--                         = 1 / 2 ^ N * ‚àë_{i=0..k-1} (1 / 2) ^ i
--                         ‚â§ 1 / 2 ^ N * 2 < Œµ
theorem cauchySeq_of_le_geometric_two' {u : ‚Ñï ‚Üí X}
    (hu : ‚àÄ n : ‚Ñï, dist (u n) (u (n + 1)) ‚â§ (1 / 2) ^ n) : CauchySeq u := by
  -- Using the definition of a Cauchy sequence,
  -- Show ‚àÄ Œµ > 0, ‚àÉ N ‚àà ‚Ñï, ‚àÄ n ‚â• N, dist(u‚Çô, u_N) < Œµ.
  rw [Metric.cauchySeq_iff']
  -- Let Œµ > 0.
  -- Show ‚àÉ N ‚àà ‚Ñï, ‚àÄ n ‚â• N, dist(u‚Çô, u_N) < Œµ.
  intro Œµ Œµ_pos
  -- Lemma: ‚àÉ N ‚àà ‚Ñï, 1 / 2 ^ N < Œµ.
  -- Let N be such that 1 / 2 ^ N < Œµ.
  -- log2(1 / Œµ) < N-1
  obtain ‚ü®N, hN‚ü© : ‚àÉ N : ‚Ñï, 1 / 2 ^ N * 2 < Œµ := by
    -- Show ‚àÉ N ‚àà ‚Ñï, 1 / 2 ^ N < Œµ.
    -- First, we can show that the sequence (1 / 2 ^ n) converges to 0.
    have : Tendsto (fun n : ‚Ñï ‚Ü¶ (1 / 2 ^ n : ‚Ñù)) atTop (ùìù 0) := by
      -- Show the sequence (1 / 2 ^ n) converges to 0.
      -- Equivalently, show ((1 / 2) ^ n) converges to 0.
      simp_rw [‚Üê one_div_pow]
      -- Since 0 ‚â§ 1 / 2 < 1, (1 / 2) ^ n converges to 0.
      have h‚ÇÅ : 1 / (2 : ‚Ñù) ‚â• 0 := one_div_nonneg.mpr zero_le_two
      have h‚ÇÇ : 1 / (2 : ‚Ñù) < 1 := one_half_lt_one
      exact tendsto_pow_atTop_nhds_zero_of_lt_one h‚ÇÅ h‚ÇÇ
    -- This means ‚àÄ Œµ > 0, ‚àÉ N ‚àà ‚Ñï, ‚àÄ n ‚â• N, dist(1 / 2 ^ n, 0) < Œµ.
    rw [Metric.tendsto_atTop] at this
    -- Using this with Œµ / 2 > 0, we can find N s.t.
    -- ‚àÄ n ‚â• N, dist(1 / 2 ^ n, 0) < Œµ / 2.
    rcases this (Œµ / 2) (half_pos Œµ_pos) with ‚ü®N, hN‚ü©
    -- Use N. Show  1 / 2 ^ N * 2 < Œµ.
    use N
    -- Since N ‚â• N, dist(1 / 2 ^ N, 0) < Œµ / 2.
    have := hN N (le_refl N)
    -- Then, |1 / 2 ^ N| < Œµ / 2.
    rw [Real.dist_0_eq_abs] at this
    -- Since 1 / 2 ^ N > 0, 1 / 2 ^ N < Œµ / 2.
    have h : 0 ‚â§ 1 / (2 : ‚Ñù) ^ N := one_div_nonneg.mpr (pow_nonneg zero_le_two N)
    rw [abs_of_nonneg h] at this
    -- Then 1 / 2 ^ N * 2 < (Œµ / 2) * 2 = Œµ.
    calc
      1 / 2 ^ N * 2 < (Œµ / 2) * 2 := by apply mul_lt_mul_of_pos_right this two_pos
      _ = Œµ := div_mul_cancel_of_invertible Œµ 2
  -- Use N.
  -- Show ‚àÄ n ‚â• N, dist(u‚Çô, u_N) < Œµ.
  use N
  -- Let n ‚â• N.
  -- Show dist(u‚Çô, u_N) < Œµ.
  intro n hn
  -- Since n ‚â• N, ‚àÉ k ‚àà ‚Ñï s.t. n = N + k. Fix such k.
  -- Show dist(u_{N + k}, u_N) < Œµ.
  obtain ‚ü®k, rfl : n = N + k‚ü© := le_iff_exists_add.mp hn
  -- dist(u_{N + k}, u_N) = dist(u_{N + 0}, u_{N + k})
  --                      ‚â§ ‚àë_{i=0..k-1}, dist(u_{N + i}, u_{N + (i + 1)})
  --                      ‚â§ ‚àë_{i=0..k-1}, (1 / 2) ^ (N + i)
  --                      = 1 / 2 ^ N * ‚àë_{i=0..k-1}, (1 / 2) ^ i
  --                      ‚â§ 1 / 2 ^ N * 2
  --                      < Œµ.
  calc
    dist (u (N + k)) (u N) = dist (u (N + 0)) (u (N + k)) := by
      -- Show dist(u_{N + k}, u_N) = dist(u_{N + 0}, u_{N + k}).
      -- Since dist is symmetric, dist(u_{N + k}, u_N) = dist(u_N, u_{N + k}).
      rw [dist_comm]
      -- Since N = N + 0, dist(u_N, u_{N + k}) = dist(u_{N + 0}, u_{N + k}).
      rw [add_zero N]
    _ ‚â§ ‚àë i in range k, dist (u (N + i)) (u (N + (i + 1))) :=
      -- Show dist(u_{N + 0}, u_{N + k}) ‚â§ ‚àë_{i=0..k-1} dist(u_{N + i}, u_{N + (i + 1)}).
      -- Using the triangle inequality,
      -- dist(u_{N + 0}, u_{N + k})
      -- = ‚Äñ u_{N + 0} - u_{N + k} ‚Äñ
      -- = ‚Äñ (u_{N + 0} - u_{N + 1}) + (u_{N + 1} - u_{N + 2}) + ... + (u_{N + (k - 1)} - u_{N + k}) ‚Äñ
      -- = ‚Äñ ‚àë_{i=0..k-1} (u_{N + i} - u_{N + (i + 1)}) ‚Äñ
      -- ‚â§ ‚àë_{i=0..k-1} ‚Äñ u_{N + i} - u_{N + (i + 1)} ‚Äñ
      -- = ‚àë_{i=0..k-1} dist(u_{N + i}, u_{N + (i + 1)}).
      dist_le_range_sum_dist (fun i => u (N + i)) k
    _ ‚â§ ‚àë i in range k, (1 / 2 : ‚Ñù) ^ (N + i) :=
      -- Show ‚àë_{i=0..k-1} dist(u_{N + i}, u_{N + (i + 1)}) ‚â§ ‚àë_{i=0..k-1} (1 / 2) ^ (N + i).
      -- Since ‚àÄ i = 0..k-1, dist(u_{N + i}, u_{N + (i + 1)}) ‚â§ (1 / 2) ^ (N + i),
      -- ‚àë_{i=0..k-1} dist(u_{N + i}, u_{N + (i + 1)}) ‚â§ ‚àë_{i=0..k-1} (1 / 2) ^ (N + i).
      sum_le_sum fun i _ => hu (N + i)
    _ = 1 / 2 ^ N * ‚àë i in range k, (1 / 2 : ‚Ñù) ^ i := by
      -- Show ‚àë_{i=0..k-1} (1 / 2) ^ (N + i) = 1 / 2 ^ N * ‚àë_{i=0..k-1} (1 / 2) ^ i.
      -- ‚àë_{i=0..k-1} (1 / 2) ^ (N + i)
      -- = ‚àë_{i=0..k-1} (1 / 2) ^ N * (1 / 2) ^ i
      -- = (1 / 2) ^ N * ‚àë_{i=0..k-1} (1 / 2) ^ i.
      -- = 1 / 2 ^ N * ‚àë_{i=0..k-1} (1 / 2) ^ i.
      simp_rw [‚Üê one_div_pow, pow_add, mul_sum]
    _ ‚â§ 1 / 2 ^ N * 2 := by
      -- Show 1 / 2 ^ N * ‚àë_{i=0..k-1} (1 / 2) ^ i ‚â§ 1 / 2 ^ N * 2.
      apply mul_le_mul_of_nonneg_left
      ¬∑ -- Show ‚àë_{i=0..k-1} (1 / 2) ^ i ‚â§ 2.
        -- Since k ‚àà ‚Ñï, ‚àë_{i=0..k-1} (1 / 2) ^ i ‚â§ ‚àë_{i=0..‚àû} (1 / 2) ^ i = 2.
        exact sum_geometric_two_le k
      ¬∑ -- Show 0 ‚â§ 1 / 2 ^ N.
        -- Since N ‚àà ‚Ñï and 2 ‚â• 0, 2 ^ N > 0, 1 / 2 ^ N > 0.
        exact one_div_nonneg.mpr (pow_nonneg zero_le_two N)
    _ < Œµ :=
      -- From above, 1 / 2 ^ N * 2 < Œµ.
      hN

open Metric

-- A set is dense in a space if every point in the space is in the closure of the set.
-- Intuition: the set is "everywhere" in the space.
example (s : Set X) : Dense s = ‚àÄ (x : X), x ‚àà closure s := rfl

-- Example: ‚Ñö is dense in ‚Ñù.
-- Proof: there is a rational number between any two real numbers.
example : Dense (range ((‚Üë) : ‚Ñö ‚Üí ‚Ñù) : Set ‚Ñù) := by
  rw [dense_iff_exists_between]
  intro a b hab
  rcases exists_rat_btwn hab with ‚ü®q, hq‚ü©
  use q
  exact ‚ü®mem_range_self q, hq‚ü©

-- The intersection of a family of open and dense sets in a complete space is dense.
-- Given:
--   metric space X
--   family of sets (f‚Çô)
-- If:
--   X is complete
--   ‚àÄ n, f‚Çô is open
--   ‚àÄ n, f‚Çô is dense
-- Then:
--   ‚ãÇ f‚Çô is dense
-- Proof sketch:
--   1. For each index n, point x, and radius Œ¥,
--      we can find a center y and a positive radius r s.t.
--      the closed ball centered at y with radius r is included in
--      both f‚Çô and the closed ball centered at x with radius Œ¥.
--   2. To show that ‚ãÇ f‚Çô is dense, we have to show that every point x in ‚ãÇ f‚Çô
--      is in the closure of ‚ãÇ f‚Çô.
--   3. Since closed balls centered at x form a basis of the neighborhood filter at x,
--      we have to find, for every positive radius Œµ, a point y in the closed ball of radius Œµ around x
--      belonging to all f‚Çô.
--   4. We construct inductively a sequence F‚Çô = (c‚Çô, r‚Çô) such that
--      the closed ball cB(c‚Çô, r‚Çô) is included in the previous ball and in f‚Çô
--   5. The sequence of centers (c‚Çô) is Cauchy, and hence converges to a point y.
--   6. This point y is the point we want to find.
--        y belongs to all f‚Çô, and hence to ‚ãÇ f‚Çô.
--        y belongs to all closed balls centered at x.
example [CompleteSpace X] (f : ‚Ñï ‚Üí Set X) (ho : ‚àÄ n, IsOpen (f n)) (hd : ‚àÄ n, Dense (f n)) :
    Dense (‚ãÇ n, f n) := by
  -- Let B : ‚Ñï ‚Üí ‚Ñù s.t. B(n) = (1 / 2) ^ n.
  let B : ‚Ñï ‚Üí ‚Ñù := fun n ‚Ü¶ (1 / 2) ^ n
  -- Then, since 1 / 2 > 0, ‚àÄ n ‚àà ‚Ñï, B(n) > 0.
  have Bpos : ‚àÄ n, 0 < B n := fun n => pow_pos (one_half_pos) n
  -- Since f‚Çô is dense ‚àÄ n ‚àà ‚Ñï, we can find for each index n, point x, and Œ¥ > 0
  -- a center y and a positive radius r s.t. the closed ball centered at c with radius r
  --   is included in both f‚Çô and the closed ball centered at x with radius Œ¥
  --   r ‚â§ B(n + 1) = (1 / 2) ^ (n + 1) (to ensure that the sequence (c‚Çô) is Cauchy)
  -- Formally, ‚àÄ n ‚àà ‚Ñï, ‚àÄ x ‚àà X, ‚àÄ Œ¥ > 0,
  --           ‚àÉ y ‚àà X, ‚àÉ r > 0, r ‚â§ B(n + 1) ‚àß cB(y, r) ‚äÜ cB(x, Œ¥) ‚à© f‚Çô
  have :
    ‚àÄ (n : ‚Ñï) (x : X), ‚àÄ Œ¥ > 0,
    ‚àÉ y : X, ‚àÉ r > 0, r ‚â§ B (n + 1) ‚àß closedBall y r ‚äÜ closedBall x Œ¥ ‚à© f n :=
    by
    -- Let n ‚àà ‚Ñï, x ‚àà X, and Œ¥ > 0.
    -- Show ‚àÉ y ‚àà X, ‚àÉ r > 0, r ‚â§ B(n + 1) and cB(y, r) ‚äÜ cB(x, Œ¥) ‚à© f‚Çô.
    intro n x Œ¥ hŒ¥pos
    -- Since f‚Çô is dense, ‚àÄ x ‚àà X, ‚àÄ r > 0, ‚àÉ y ‚àà f‚Çô, y ‚àà cB(x, r).
    have hdn := hd n
    rw [dense_iff] at hdn
    -- Use with center x and radius Œ¥ / 2 > 0,
    -- we get a point y ‚àà f‚Çô s.t. y ‚àà cB(x, Œ¥ / 2).
    rcases hdn x (Œ¥ / 2) (half_pos hŒ¥pos) with ‚ü®y, hyb, hyfn‚ü©
    -- Since f‚Çô is open, ‚àÄ y ‚àà f‚Çô, ‚àÉ Œµ > 0 s.t. B(y, Œµ) ‚äÜ f‚Çô.
    have hon := ho n
    rw [Metric.isOpen_iff] at hon
    -- Use with y, we get Œµ > 0 s.t. B(y, Œµ) ‚äÜ f‚Çô.
    rcases hon y hyfn with ‚ü®Œµ, hŒµpos, hbyŒµfn‚ü©
    -- Let r = min(B(n + 1), Œ¥ / 2, Œµ / 2).
    -- Motivation:
    --   small enough radius r ‚â§ B(n + 1) as required
    --   since y ‚àà cB(x, Œ¥ / 2), r ‚â§ Œ¥ / 2 to ensure cB(y, r) ‚äÜ cB(x, Œ¥)
    --   since B(y, Œµ) ‚äÜ f‚Çô, r < Œµ to ensure cB(y, r) ‚äÜ f‚Çô
    let r := min (B (n + 1)) (min (Œ¥ / 2) (Œµ / 2))
    -- Then, r > 0
    have hrpos : r > 0 :=
      -- B(n + 1) > 0, Œ¥ / 2 > 0, Œµ / 2 > 0, so r > 0
      lt_min (Bpos (n + 1)) (lt_min (half_pos hŒ¥pos) (half_pos hŒµpos))
    -- and r ‚â§ B(n + 1)
    have hrB : r ‚â§ B (n + 1) :=
      -- r ‚â§ B(n + 1)
      min_le_left _ _
    -- and r ‚â§ Œ¥ / 2
    have hrŒ¥ : r ‚â§ Œ¥ / 2 :=
      -- r ‚â§ min(Œ¥ / 2, Œµ / 2) ‚â§ Œ¥ / 2
      le_trans (min_le_right _ _) (min_le_left _ _)
    -- and r < Œµ
    have hrŒµ : r < Œµ :=
      -- r ‚â§ min(Œ¥ / 2, Œµ / 2) ‚â§ Œµ / 2 < Œµ
      lt_of_le_of_lt (min_le_right _ _)
        (lt_of_le_of_lt (min_le_right _ _) (half_lt_self hŒµpos))
    use y, r, hrpos, hrB
    -- Show cB(y, r) ‚äÜ cB(x, Œ¥) ‚à© f‚Çô.
    -- Let z ‚àà cB(y, r).
    intro z hz
    -- Show z ‚àà cB(x, Œ¥) and z ‚àà f‚Çô.
    constructor
    ¬∑ -- Show z ‚àà cB(x, Œ¥).
      -- Equivalently, show dist(z, x) ‚â§ Œ¥.
      rw [mem_closedBall]
      -- dist(z, x) ‚â§ dist(z, y) + dist(y, x) (‚àµ triangle inequality)
      --            ‚â§ Œ¥ / 2 + Œ¥ / 2 (‚àµ z ‚àà cB(y, r) with r ‚â§ Œ¥ / 2 and y ‚àà cB(x, Œ¥ / 2))
      --            ‚â§ Œ¥ / 2 + Œ¥ / 2 = Œ¥
      calc
        dist z x ‚â§ dist z y + dist y x := dist_triangle z y x
        _ ‚â§ Œ¥ / 2 + Œ¥ / 2 := add_le_add (le_trans hz hrŒ¥) (le_of_lt hyb)
        _ = Œ¥ := add_halves Œ¥
    ¬∑ -- Show z ‚àà f‚Çô.
      -- Since B(y, Œµ) ‚äÜ f‚Çô, it suffices to
      -- show z ‚àà B(y, Œµ).
      apply hbyŒµfn
      -- Equivalently, show dist(z, y) < Œµ.
      rw [mem_ball]
      -- Since z ‚àà cB(y, r) with r < Œµ,
      -- dist(z, y) ‚â§ r < Œµ.
      exact lt_of_le_of_lt hz hrŒµ
  -- Let `center` and `radius` be functions s.t.
  -- `center`(n, c, Œ¥) = y and `radius`(n, c, Œ¥) = r s.t.
  --   cB(y, r) ‚äÜ cB(c, Œ¥) ‚à© f‚Çô
  --   r ‚â§ B(n + 1)
  choose! center radius Hpos HB Hball using this
  -- Let x ‚àà X.
  -- Show x ‚àà cl(‚ãÇ f‚Çô).
  intro x
  -- Since closed balls form a basis of the neighborhood filter at x, to show x ‚àà cl(‚ãÇ f‚Çô)
  -- we have to find, for every positive radius Œµ,
  -- a point y in the closed ball of radius Œµ around x
  -- belonging to all f‚Çô.
  -- Show ‚àÄ Œµ > 0, ‚àÉ y ‚àà ‚ãÇ f‚Çô, y ‚àà cB(x, Œµ).
  rw [mem_closure_iff_nhds_basis nhds_basis_closedBall]
  -- Let Œµ > 0.
  -- Show ‚àÉ y ‚àà ‚ãÇ f‚Çô, y ‚àà cB(x, Œµ).
  intro Œµ Œµpos
  -- We construct inductively a sequence F‚Çô = (c‚Çô, r‚Çô) such that
  -- the closed ball cB(c‚Çô, r‚Çô)
  --   is included in the previous ball and in f‚Çô
  --     i.e., cB(c‚Çô, r‚Çô) ‚äÜ cB(c_{n-1}, r_{n-1}) ‚à© f‚Çô
  --   the radius is positive and small enough that c‚Çô is a Cauchy sequence
  --     i.e., 0 < r‚Çô ‚â§ B(n)
  -- Specifically,
  --   F‚ÇÄ = (c‚ÇÄ, r‚ÇÄ)      F‚Çô‚Çä‚ÇÅ = (c‚Çô‚Çä‚ÇÅ, r‚Çô‚Çä‚ÇÅ)
  -- where
  --   c‚ÇÄ = x             c‚Çô‚Çä‚ÇÅ = `center`(n, c‚Çô, r‚Çô)
  --   r‚ÇÄ = B(0)          r‚Çô‚Çä‚ÇÅ = `radius`(n, c‚Çô, r‚Çô)
  -- By the definition of `center` and `radius`, the properties are satisfied.
  let F : ‚Ñï ‚Üí X √ó ‚Ñù := fun n ‚Ü¶
    Nat.recOn n
      (Prod.mk x (min Œµ (B 0)))
      fun n p ‚Ü¶ Prod.mk (center n p.1 p.2) (radius n p.1 p.2)
  let c : ‚Ñï ‚Üí X := fun n ‚Ü¶ (F n).1
  let r : ‚Ñï ‚Üí ‚Ñù := fun n ‚Ü¶ (F n).2
  -- We show that r‚Çô > 0 for all n.
  have rpos : ‚àÄ n, 0 < r n := by
    -- Let n ‚àà ‚Ñï.
    intro n
    -- We prove by induction on n.
    -- IH: If r‚Çô > 0, then r‚Çô‚Çä‚ÇÅ > 0.
    induction' n with n hn
    ¬∑ -- Show r‚ÇÄ = min(Œµ, B(0)) > 0.
      -- Since Œµ > 0 and B(0) > 0 (‚àµ B(n) > 0 for all n),
      -- r‚ÇÄ > 0.
      exact lt_min Œµpos (Bpos 0)
    ¬∑ -- Show r‚Çô‚Çä‚ÇÅ = `radius`(n, c‚Çô, r‚Çô) > 0.
      -- By the IH, r‚Çô > 0.
      -- Then, `radius`(n, c‚Çô, r‚Çô) > 0.
      -- Thus, r‚Çô‚Çä‚ÇÅ > 0.
      exact Hpos n (c n) (r n) hn
  -- We show that r‚Çô ‚â§ B(n) for all n.
  have rB : ‚àÄ n, r n ‚â§ B n := by
    -- Let n ‚àà ‚Ñï.
    intro n
    -- We prove by induction on n.
    -- IH: If r‚Çô ‚â§ B(n), then r‚Çô‚Çä‚ÇÅ ‚â§ B(n + 1).
    induction' n with n hn
    ¬∑ -- Show r‚ÇÄ = min(Œµ, B(0)) ‚â§ B(0).
      -- Since r‚ÇÄ = min(Œµ, B(0)), r‚ÇÄ ‚â§ B(0).
      exact min_le_right Œµ (B 0)
    ¬∑ -- Show r‚Çô‚Çä‚ÇÅ = `radius`(n, c‚Çô, r‚Çô) ‚â§ B(n + 1).
      -- Since r‚Çô > 0 (‚àµ r‚Çô > 0 for all n),
      -- `radius`(n, c‚Çô, r‚Çô) ‚â§ B(n + 1).
      exact HB n (c n) (r n) (rpos n)
  -- We show that cB(c‚Çô‚Çä‚ÇÅ, r‚Çô‚Çä‚ÇÅ) ‚äÜ cB(c‚Çô, r‚Çô) ‚à© f‚Çô for all n.
  have incl : ‚àÄ n, closedBall (c (n + 1)) (r (n + 1)) ‚äÜ closedBall (c n) (r n) ‚à© f n := by
    -- Let n ‚àà ‚Ñï.
    intro n
    -- By the definition of `center` and `radius`,
    -- with r‚Çô > 0 (‚àµ r‚Çô > 0 for all n),
    -- cB(c‚Çô‚Çä‚ÇÅ, r‚Çô‚Çä‚ÇÅ) = cB(`center`(n, c‚Çô, r‚Çô), `radius`(n, c‚Çô, r‚Çô))
    --                ‚äÜ cB(c‚Çô, r‚Çô) ‚à© f‚Çô.
    exact Hball n (c n) (r n) (rpos n)
  -- We show that dist(c‚Çô, c‚Çô‚Çä‚ÇÅ) ‚â§ B(n) for all n.
  have cdist : ‚àÄ n, dist (c n) (c (n + 1)) ‚â§ B n := by
    -- Let n ‚àà ‚Ñï.
    intro n
    -- Since r‚Çô‚Çä‚ÇÅ > 0 (‚àµ r‚Çô‚Çä‚ÇÅ > 0 for all n), r‚Çô‚Çä‚ÇÅ ‚â• 0.
    -- Then, c‚Çô‚Çä‚ÇÅ ‚àà cB(c‚Çô‚Çä‚ÇÅ, r‚Çô‚Çä‚ÇÅ) (‚àµ c‚Çô‚Çä‚ÇÅ is the center of the ball).
    -- Since cB(c‚Çô‚Çä‚ÇÅ, r‚Çô‚Çä‚ÇÅ) ‚äÜ cB(c‚Çô, r‚Çô) ‚à© f‚Çô, c‚Çô‚Çä‚ÇÅ ‚àà cB(c‚Çô, r‚Çô) ‚à© f‚Çô.
    -- Thus, c‚Çô‚Çä‚ÇÅ ‚àà cB(c‚Çô, r‚Çô).
    have : c (n + 1) ‚àà closedBall (c n) (r n) :=
      (rpos (n + 1) |> le_of_lt |> mem_closedBall_self |> incl n).left
    -- Then, dist(c‚Çô, c‚Çô‚Çä‚ÇÅ) ‚â§ r‚Çô.
    rw [mem_closedBall'] at this
    -- Since r‚Çô ‚â§ B(n), dist(c‚Çô, c‚Çô‚Çä‚ÇÅ) ‚â§ B(n).
    exact le_trans this (rB n)
  -- Using that and the above result, we show that the sequence (c‚Çô) is Cauchy.
  have : CauchySeq c := cauchySeq_of_le_geometric_two' cdist
  -- As (c‚Çô) is Cauchy in a complete space, it converges to a limit y.
  rcases cauchySeq_tendsto_of_complete this with ‚ü®y, ylim‚ü©
  -- Use y.
  -- Show y ‚àà ‚ãÇ f‚Çô and y ‚àà cB(x, Œµ).
  use y
  -- We have that ‚àÄ n ‚àà ‚Ñï, ‚àÄ m ‚â• n, cB(c‚Çò, r‚Çò) ‚äÜ cB(c‚Çô, r‚Çô).
  have I : ‚àÄ n, ‚àÄ m ‚â• n, closedBall (c m) (r m) ‚äÜ closedBall (c n) (r n) := by
    -- Let n ‚àà ‚Ñï.
    intro n
    -- We prove by induction on m.
    apply Nat.le_induction
    ¬∑ -- Show cB(c‚Çô, r‚Çô) ‚äÜ cB(c‚Çô, r‚Çô).
      exact subset_refl (closedBall (c n) (r n))
    ¬∑ -- Show ‚àÄ m ‚â• n, cB(c‚Çò, r‚Çò) ‚äÜ cB(c‚Çô, r‚Çô) ‚Üí cB(c‚Çò‚Çä‚ÇÅ, r‚Çò‚Çä‚ÇÅ) ‚äÜ cB(c‚Çô, r‚Çô).
      -- Let m ‚â• n. Suppose cB(c‚Çò, r‚Çò) ‚äÜ cB(c‚Çô, r‚Çô).
      -- Show cB(c‚Çò‚Çä‚ÇÅ, r‚Çò‚Çä‚ÇÅ) ‚äÜ cB(c‚Çô, r‚Çô).
      intro m _ hss
      -- cB(c‚Çò‚Çä‚ÇÅ, r‚Çò‚Çä‚ÇÅ) ‚äÜ cB(c‚Çò, r‚Çò) ‚à© f‚Çò ‚äÜ cB(c‚Çò, r‚Çò) ‚äÜ cB(c‚Çô, r‚Çô)
      exact ((incl m).trans Set.inter_subset_left).trans hss
  -- Then, ‚àÄ n ‚àà ‚Ñï, y ‚àà cB(c‚Çô, r‚Çô).
  have yball : ‚àÄ n, y ‚àà closedBall (c n) (r n) := by
    -- Let n ‚àà ‚Ñï.
    -- Show y ‚àà cB(c‚Çô, r‚Çô).
    intro n
    -- Since cB(c‚Çô, r‚Çô) is closed,
    -- for the limit y of the sequence (c‚Çô) to be in cB(c‚Çô, r‚Çô),
    -- it suffices to show that c‚Çò ‚àà cB(c‚Çò, r‚Çò) for sufficiently large m.
    apply isClosed_ball.mem_of_tendsto ylim
    -- Equivalently, show that for all m ‚â• n, c‚Çò ‚àà cB(c‚Çô, r‚Çô).
    apply (eventually_ge_atTop n).mono
    -- Let m ‚â• n.
    intro m hnm
    -- Since m ‚àà ‚Ñï, r(m) > 0 and hence r(m) ‚â• 0.
    -- Then, c(m) ‚àà cB(c(m), r(m)).
    -- Since m ‚â• n, cB(c(m), r(m)) ‚äÜ cB(c(n), r(n)),
    -- i.e., c(m) ‚àà cB(c(n), r(n)).
    exact rpos m |> le_of_lt |> mem_closedBall_self |> I n m hnm
  constructor
  ¬∑ -- Show y ‚àà ‚ãÇ f‚Çô.
    -- Equivalently, show ‚àÄ n ‚àà ‚Ñï, y ‚àà f‚Çô.
    rw [mem_iInter]
    -- Let n ‚àà ‚Ñï.
    intro n
    -- Since y ‚àà cB(c‚Çô‚Çä‚ÇÅ, r‚Çô‚Çä‚ÇÅ) (‚àµ y ‚àà cB(c‚Çô, r‚Çô) for all n),
    -- and cB(c‚Çô‚Çä‚ÇÅ, r‚Çô‚Çä‚ÇÅ) ‚äÜ cB(c‚Çô, r‚Çô) ‚à© f‚Çô ‚äÜ f‚Çô,
    -- y ‚àà f‚Çô.
    exact ((n + 1) |> yball |> incl n).right
  ¬∑ -- Show y ‚àà cB(x, Œµ).
    -- Equivalently, show dist(y, x) ‚â§ Œµ.
    rw [mem_closedBall]
    -- We have y ‚àà cB(c‚ÇÄ, r‚ÇÄ) = cB(x, min(Œµ, B(0))).
    -- Then, dist(y, x) ‚â§ r‚ÇÄ = min(Œµ, B(0)).
    -- Thus, dist(y, x) ‚â§ min(Œµ, B(0)) ‚â§ Œµ.
    exact le_trans (yball 0) (min_le_left Œµ (B 0))
