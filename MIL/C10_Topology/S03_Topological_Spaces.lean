import MIL.Common
import Mathlib.Topology.Instances.Real
import Mathlib.Analysis.Normed.Operator.BanachSteinhaus

open Set Filter Topology

-- 10.3. Topological spaces

-- 10.3.1. Fundamentals

-- There is no need to rely on a metric to define a topology.

-- First point of view: using open sets

-- A topological space is a set X and a topology on X.
-- A topology on X is a collection of subsets of X, called open sets, s.t.
--   1. The empty set and X are open.
--   2. The union of any collection of open sets is open.
--   3. The intersection of any finite collection of open sets is open.

-- Intuition: an open set contains a neighborhood of each of its points.
-- Intuition: an open set is a neighborhood around each of its points.

section

-- Let X be a topological space.
variable {X : Type*} [TopologicalSpace X]

-- X is open.
-- Intuition: X contains all neighborhoods,
--            including all neighborhoods of its points.
example : IsOpen (univ : Set X) :=
  isOpen_univ

-- The empty set ‚àÖ is open.
-- Intuition: the empty set contains no points,
--            so it trivially contains all neighborhoods of its points.
example : IsOpen (‚àÖ : Set X) :=
  isOpen_empty

-- The union of any collection of open sets is open.
-- Note that there is no restriction on the index set Œπ.
-- Intuition: the union of neighborhoods is a neighborhood.
example {Œπ : Type*} {s : Œπ ‚Üí Set X} (hs : ‚àÄ i, IsOpen (s i)) : IsOpen (‚ãÉ i, s i) :=
  isOpen_iUnion hs

-- The intersection of any finite collection of open sets is open.
-- Note that the index set Œπ is finite.
-- Intuition: finite intersection of neighborhoods is a neighborhood.
--            however, if there are infinitely many neighborhoods,
--            the intersection may "zoom in" too much and not be a neighborhood.
example {Œπ : Type*} [Fintype Œπ] {s : Œπ ‚Üí Set X} (hs : ‚àÄ i, IsOpen (s i)) :
    IsOpen (‚ãÇ i, s i) :=
  isOpen_iInter_of_finite hs

-- Example: ‚ãÇ‚Çô (-1/(n+1), 1/(n+1)) is closed
-- Proof: the intersection is {0}, which is closed.
example : IsClosed (‚ãÇ n : ‚Ñï, Ioo (-(1 : ‚Ñù) / (n + 1)) ((1 : ‚Ñù) / (n + 1))) := by
  -- Show ‚ãÇ‚Çô (-1/(n+1), 1/(n+1)) = {0}.
  have : (‚ãÇ n : ‚Ñï, Ioo (-(1 : ‚Ñù) / (n + 1)) ((1 : ‚Ñù) / (n + 1))) = {0} := by
    ext x
    constructor
    ¬∑ -- Suppose x ‚àà ‚ãÇ‚Çô (-1/(n+1), 1/(n+1)).
      -- Show x = 0.
      intro h
      -- Then, ‚àÄ n ‚àà ‚Ñï, x ‚àà (-1/(n+1)) (1/(n+1)).
      rw [mem_iInter] at h
      -- Suppose for contradiction x ‚â† 0.
      by_contra! hxne0
      by_cases hx : 0 < x
      ¬∑ -- Case 1: x > 0.
        -- Then, ‚àÉ n ‚àà ‚Ñï, x > 1/(n+1).
        rcases exists_nat_one_div_lt hx with ‚ü®n, hxn‚ü©
        -- Fix such n. We have x ‚àà (-1/(n+1), 1/(n+1)).
        have := h n
        -- This is a contradiction.
        exact not_lt_of_le (le_of_lt this.right) hxn
      ¬∑ -- Case 2: x < 0.
        push_neg at hx
        have hx := lt_of_le_of_ne hx hxne0
        -- Then, ‚àÉ n ‚àà ‚Ñï, x < -1/(n+1).
        rcases exists_nat_one_div_lt (neg_pos.mpr hx) with ‚ü®n, hxn‚ü©
        -- Fix such n. We have x ‚àà (-1/(n+1), 1/(n+1)).
        have := h n
        -- This is a contradiction.
        have := this.left
        rw [neg_div, neg_lt] at this
        exact not_lt_of_lt hxn this
    ¬∑ -- Suppose x = 0.
      -- Show x ‚àà ‚ãÇ n, (-1/(n+1), 1/(n+1)).
      intro h
      -- Show ‚àÄ n ‚àà ‚Ñï, x ‚àà (-1/(n+1), 1/(n+1)).
      rw [mem_iInter]
      -- Let n ‚àà ‚Ñï.
      -- show x ‚àà (-1/(n+1), 1/(n+1)).
      intro n
      -- Show -1/(n+1) < x < 1/(n+1).
      rw [mem_Ioo]
      constructor
      ¬∑ -- Show -1/(n+1) < x.
        -- Since x = 0, this is trivial.
        rw [h]
        rw [neg_div]
        exact neg_neg_of_pos Nat.one_div_pos_of_nat
      ¬∑ -- Show x < 1/(n+1).
        -- Since x = 0, this is trivial.
        rw [h]
        exact Nat.one_div_pos_of_nat
  -- The intersection is {0}, which is closed.
  rw [this]
  exact isClosed_singleton

-- Some view this collection of axioms as redundant:
--   The empty set is open because it is the union of no open sets.
--   The universe is open because it is the intersection of no open sets.

-- Let Y be a topological space.
variable {Y : Type*} [TopologicalSpace Y]

-- A set is closed if its complement is open.
example {S : Set X} : IsOpen S·∂ú ‚Üî IsClosed S := isOpen_compl_iff

-- A function between two topological spaces is continuous
-- if the preimage of every open set in the codomain is open in the domain.
-- Intuition: continuous function preserves "neighborhoods",
--            i.e., points that are close together in the domain
--                  are mapped to points that are close together in the codomain.
example {f : X ‚Üí Y} : Continuous f ‚Üî ‚àÄ s, IsOpen s ‚Üí IsOpen (f ‚Åª¬π' s) :=
  continuous_def

-- A topological structure determines which functions (with domain
-- and codomain in the topological space) are continuous.
-- Two topological structures on the same set are the same
-- if they have the same continuous functions.
-- The identity function is used as a witness of equivalence:
--   if the identity function is continuous in both directions,
--   then an open set in one topology has to be open in the other topology,
--   thus the two topologies are the same.

-- Second point of view: using neighborhoods

-- A topological space is a set equipped with
-- a neighborhood filter ùìù(x) attached to each point x,
-- i.e., there is a neighborhood function mapping each point x to a filter ùìù(x)
--       called the neighborhood of x.
-- Two roles of this neighborhood filter (as previously studied):
-- 1. ùìù(x) is the generalized set of points of X close to x.
-- 2. ùìù(x) gives a way to say a predicate `P : X ‚Üí Prop` holds
--    for points close enough to x.

-- Motivation: easier to talk about continuity at a point

-- Continuity at a point:

-- Filter
-- A function f : X ‚Üí Y is continuous at x if
-- the direct image under f of the generalized set of points close to x
-- is contained in the generalized set of points close to f(x).
-- Formally, f(ùìù(x)) ‚â§ ùìù(f(x))
-- i.e., ùìù(f(x)) ‚äÜ f(ùìù(x)) (not expressible in Lean)
-- i.e., ‚àÄ V ‚àà ùìù(f(x)), V ‚àà f(ùìù(x))
-- i.e., ‚àÄ V ‚àà ùìù(f(x)), f‚Åª¬π(V) ‚àà ùìù(x)
-- i.e., ‚àÄ V ‚àà ùìù(f(x)), ‚àÉ U ‚àà ùìù(x), f(U) = V
-- Note: it does not mean any neighborhood of x is mapped to a neighborhood of f(x)
--       more like there exists a neighborhood of x mapped to any neighborhood of f(x)
example {f : X ‚Üí Y} {x : X} : ContinuousAt f x ‚Üî map f (ùìù x) ‚â§ ùìù (f x) :=
  Iff.rfl

-- Ordinary set
-- A function f is continuous at x iff
-- for every neighborhood U of f(x), all points sufficiently close to x
-- are sent to U.
example {f : X ‚Üí Y} {x : X} : ContinuousAt f x ‚Üî ‚àÄ U ‚àà ùìù (f x), ‚àÄ·∂† x in ùìù x, f x ‚àà U :=
  Iff.rfl

-- Recall there are two points of view: open sets and neighborhood filters
-- We can go between two points of view.

-- From open sets to neighborhood filters:
-- Constructing neighborhood filters from open sets:
-- Given a point x in a topological space X equipped with a topology,
-- the neighborhood filter is defined as follows:
-- A set S ‚àà ùìù(x) (S is a neighborhood of x) iff
-- S contains an open set containing x.
example {x : X} {s : Set X} : s ‚àà ùìù x ‚Üî ‚àÉ t, t ‚äÜ s ‚àß IsOpen t ‚àß x ‚àà t :=
  mem_nhds_iff

-- From neighborhood filters to open sets:
-- The function `ùìù : X ‚Üí Filter X` needs to satisfy some properties
-- to define a topology on X.

-- The `pure x` filter:
--   generated by {x}
--   containing all sets containing x
example {x : X} : ùìü {x} = pure x := principal_singleton x

-- All subsets in ùìü({x}) contains x
-- since each of them contains {x} as a subset.
example {x : X} {S : Set X} : S ‚àà ùìü {x} ‚Üí x ‚àà S := fun hSPx ‚Ü¶ hSPx rfl

-- Property 1: a point is close to itself
--   ùìù(x) contains {x}
--   `pure x` ‚â§ ùìù(x)
example (x : X) : pure x ‚â§ ùìù x :=
  pure_le_nhds x

-- Any property that holds for points close enough to x also holds for x itself.
-- Given a point x ‚àà X and a proposition P(‚¨ù) on X
-- If P(y) holds for y sufficiently close to x
-- then P(x) holds
example (x : X) (P : X ‚Üí Prop) (h : ‚àÄ·∂† y in ùìù x, P y) : P x :=
  h.self_of_nhds

-- Property 2: nearness is transitive
-- Given a point x ‚àà X and a proposition P(¬∑) on X
-- If P(y) holds for y sufficiently close to x
-- then for y sufficiently close to x and z sufficiently close to y, P(z) holds.
-- Intuition: if y is in a neighborhood of x and z is in a neighborhood of y,
--            then z is in a (potentially larger) neighborhood of x.
-- Note: this actually goes both way
example {P : X ‚Üí Prop} {x : X} (h : ‚àÄ·∂† y in ùìù x, P y) : ‚àÄ·∂† y in ùìù x, ‚àÄ·∂† z in ùìù y, P z :=
  eventually_eventually_nhds.mpr h

-- Construct a topological space from a neighborhood function
-- However it only produces a topology where the neighborhood function
-- satisfies the two properties.
#check TopologicalSpace.mkOfNhds

-- If a neighborhood function satisfies two properties
-- then it is the same as the "true" neighborhood function.
#check TopologicalSpace.nhds_mkOfNhds

-- A neighborhood function (mapping each point to a filter)
-- satisfying the two properties above will also satisfy:
-- for any point x ‚àà X and any neighborhood S of x
-- there exists a neighborhood T ‚äÜ S such that any point x' ‚àà T
-- S is also a neighborhood of x'.
-- Given:
--   neighborhood function n : X ‚Üí Filter X
-- If:
--   (property 1) ‚àÄ x ‚àà X, ùìü({x}) ‚â§ n(x)
--   (property 2) ‚àÄ x ‚àà X, ‚àÄ proposition P(¬∑) on X,
--                if ‚àÄ·∂† y ‚àà n(x), P(y) holds then ‚àÄ·∂† y ‚àà n(x), ‚àÄ·∂† z ‚àà n(y), P(z) holds
-- Then
--   ‚àÄ x ‚àà X, ‚àÄ S ‚àà n(x), ‚àÉ T ‚àà n(x) s.t. T ‚äÜ S and ‚àÄ x' ‚àà T, S ‚àà n(x')
example {X : Type*} (n : X ‚Üí Filter X) (H‚ÇÅ : ‚àÄ x, pure x ‚â§ n x)
    (H‚ÇÇ : ‚àÄ x : X, ‚àÄ P : X ‚Üí Prop, (‚àÄ·∂† y in n x, P y) ‚Üí ‚àÄ·∂† y in n x, ‚àÄ·∂† z in n y, P z) :
    ‚àÄ x, ‚àÄ S ‚àà n x, ‚àÉ T ‚àà n x, T ‚äÜ S ‚àß ‚àÄ y ‚àà T, S ‚àà n y := by
  -- Let x ‚àà X, S ‚äÜ X s.t. S ‚àà n(x).
  -- Show: ‚àÉ T ‚àà n(x) s.t. T ‚äÜ S and ‚àÄ x' ‚àà T, S ‚àà n(x')
  intro x S hSnx
  -- Let T = {x | S ‚àà n(x)}
  -- i.e., T contains all points x having S as its neighborhood.
  use {y | S ‚àà n y}
  -- Show T ‚àà n(x)
  have hT‚ÇÅ : {y | S ‚àà n y} ‚àà n x :=
    -- In Lean, we can just write:
    -- `H‚ÇÇ x S hSnx`
    -- but that is not clear to me.
    by
    -- Since S ‚àà n(x), ‚àÄ·∂† y ‚àà n(x), y ‚àà S, read,
    -- for y sufficiently close to x, y ‚àà S.
    have : S ‚àà n x ‚Üî (‚àÄ·∂† y in n x, y ‚àà S) := Iff.rfl
    rw [this] at hSnx
    -- The goal of T ‚àà n(x) can be equivalently written as
    -- ‚àÄ·∂† y ‚àà n x, S ‚àà n(y), read,
    -- for y sufficiently close to x, S ‚àà n(y)
    -- or, equivalently,
    -- ‚àÄ·∂† y ‚àà n x, ‚àÄ·∂† z ‚àà n y, z ‚àà S, read,
    -- for y sufficiently close to x, for z sufficiently close to y, z ‚àà S.
    have : ({y | S ‚àà n y} ‚àà n x) ‚Üî (‚àÄ·∂† y in n x, ‚àÄ·∂† z in n y, z ‚àà S) := eventually_iff
    rw [this]
    -- We apply the "transitivity of nearness" property with x and P(‚¨ù) = ‚¨ù ‚àà S.
    exact H‚ÇÇ x S hSnx
  -- Show T ‚äÜ S
  have hT‚ÇÇ : {y | S ‚àà n y} ‚äÜ S :=
    -- Let y ‚àà T. Then, S ‚àà n(y).
    -- Since n(y) ‚äÜ ùìü({y}), S ‚àà ùìü({y}).
    -- Thus, y ‚àà S.
    fun y hSny ‚Ü¶ H‚ÇÅ y hSny
  -- Show ‚àÄ x' ‚àà T, S ‚àà n(x')
  have hT‚ÇÉ : ‚àÄ y ‚àà {y | S ‚àà n y}, S ‚àà n y :=
    -- Let y ‚àà T. Then, S ‚àà n(y).
    fun y a ‚Ü¶ a
  -- We complete the proof.
  exact ‚ü®hT‚ÇÅ, hT‚ÇÇ, hT‚ÇÉ‚ü©

end

-- Let X and Y be two spaces.
variable {X Y : Type*}

-- Comparing between topological spaces and metric spaces

-- Functoriality: ability to construct new structures from existing ones
-- for spaces, define structures on subsets, quotients, products, etc.

-- Metric space has limited functoriality
-- A metric space structure can be induced on a subset or,
-- equivalently, it can be pulled back by an injective map.

-- Inducing a metric space on a subset
-- Let (X, d) be a metric space. Let A ‚äÜ X.
-- Then, (A, dA) where dA(a‚ÇÅ, a‚ÇÇ) = d(a‚ÇÅ, a‚ÇÇ) ‚àÄ a‚ÇÅ, a‚ÇÇ ‚àà A, is a metric space.
def SubsetMetricSpace {X : Type*} [MetricSpace X] (A : Set X) :
  MetricSpace A where
  eq_of_dist_eq_zero := by
    intro a‚ÇÅ a‚ÇÇ h
    exact eq_of_dist_eq_zero h

-- Inducing a metric space by pulling back an injective map
-- Let f : A ‚Üí X be an injective map from a set A to a metric space (X, d).
-- Then, (A, df) where df(a‚ÇÅ, a‚ÇÇ) = d(f(a‚ÇÅ), f(a‚ÇÇ)) ‚àÄ a‚ÇÅ, a‚ÇÇ ‚àà A, is a metric space.
-- Injective is necessary to ensure df(a‚ÇÅ, a‚ÇÇ) = 0 ‚Üí a‚ÇÅ = a‚ÇÇ.
def PullbackMetricSpace {A X : Type*} (hX: MetricSpace X) (f : A ‚Üí X) (hf : Function.Injective f)
  : MetricSpace A where
  dist := fun a‚ÇÅ a‚ÇÇ => hX.dist (f a‚ÇÅ) (f a‚ÇÇ)
  dist_self := fun a => hX.dist_self (f a)
  dist_comm := fun a‚ÇÅ a‚ÇÇ => hX.dist_comm (f a‚ÇÅ) (f a‚ÇÇ)
  dist_triangle := fun a‚ÇÅ a‚ÇÇ a‚ÇÉ => hX.dist_triangle (f a‚ÇÅ) (f a‚ÇÇ) (f a‚ÇÉ)
  eq_of_dist_eq_zero := by
    intro a‚ÇÅ a‚ÇÇ h
    exact hf (hX.eq_of_dist_eq_zero h)

-- Inducing a metric space on a subset is pulling back by the inclusion map.
def SubsetMetricSpace' {X : Type*} [hX: MetricSpace X] (A : Set X) : MetricSpace A :=
  PullbackMetricSpace hX ((‚Üë) : A ‚Üí X) Subtype.coe_injective

-- The two metric space structures are the same.
example {X : Type*} [MetricSpace X] (A : Set X)
  : SubsetMetricSpace A = SubsetMetricSpace' A :=
  MetricSpace.ext rfl

-- Pulling back a metric space by an injective map is inducing a metric space on the image.
def PullbackMetricSpace' {A X : Type*} (hX : MetricSpace X) (f : A ‚Üí X) (hf : Function.Injective f)
  : MetricSpace A where
  dist := fun a‚ÇÅ a‚ÇÇ ‚Ü¶
    (SubsetMetricSpace (Set.range f)).dist (rangeFactorization f a‚ÇÅ) (rangeFactorization f a‚ÇÇ)
  dist_self := fun x ‚Ü¶
    hX.dist_self (rangeFactorization f x)
  dist_comm := fun x y ‚Ü¶
    hX.dist_comm (rangeFactorization f x) (rangeFactorization f y)
  dist_triangle := fun x y z ‚Ü¶
    hX.dist_triangle (rangeFactorization f x) (rangeFactorization f y) (rangeFactorization f z)
  eq_of_dist_eq_zero := by
    intro a‚ÇÅ a‚ÇÇ h
    exact hf (hX.eq_of_dist_eq_zero h)

-- The two metric space structures are the same.
example {A X : Type*} (hX : MetricSpace X) (f : A ‚Üí X) (hf : Function.Injective f)
  : PullbackMetricSpace hX f hf = PullbackMetricSpace' hX f hf :=
  MetricSpace.ext rfl

-- But that is pretty much everything for metric spaces.

-- For topological spaces, arbitrary functions can induce a new topology.

-- Given f : X ‚Üí Y, a topology T_X on X can be pushed forward to a topology on Y,
-- denoted by f_* T_X.
example (f : X ‚Üí Y) : TopologicalSpace X ‚Üí TopologicalSpace Y :=
  TopologicalSpace.coinduced f

-- V is open in (Y, T_Y) if its preimage is open in (X, T_X).
def PushforwardTopologicalSpace {X Y : Type*} (T_X : TopologicalSpace X) (f : X ‚Üí Y)
  : TopologicalSpace Y where
  IsOpen V := T_X.IsOpen (f ‚Åª¬π' V)
  isOpen_univ := T_X.isOpen_univ
  isOpen_inter V V' := T_X.isOpen_inter (f ‚Åª¬π' V) (f ‚Åª¬π' V')
  isOpen_sUnion S := by
    intro hS
    rw [preimage_sUnion]
    exact isOpen_biUnion hS

example [hX : TopologicalSpace X] (f : X ‚Üí Y) (V : Set Y)
  : (hX.coinduced f).IsOpen V ‚Üî hX.IsOpen (f ‚Åª¬π' V)
  := isOpen_coinduced

-- Given f : X ‚Üí Y, a topology T_Y on Y can be pulled back to a topology on X,
-- denoted by f^* T_Y.
example (f : X ‚Üí Y) : TopologicalSpace Y ‚Üí TopologicalSpace X :=
  TopologicalSpace.induced f

-- U is open in (X, T_X) iff U is the preimage of some open set in (Y, T_Y).
def PullbackTopologicalSpace {X Y : Type*} (T_Y : TopologicalSpace Y) (f : X ‚Üí Y)
  : TopologicalSpace X where
  IsOpen := fun U => ‚àÉ (V : Set Y), T_Y.IsOpen V ‚àß f ‚Åª¬π' V = U
  isOpen_univ := by
    use univ
    exact ‚ü®T_Y.isOpen_univ, rfl‚ü©
  isOpen_inter U U' := by
    rintro ‚ü®V, hV, rfl‚ü© ‚ü®V', hV', rfl‚ü©
    use V ‚à© V'
    exact ‚ü®T_Y.isOpen_inter V V' hV hV', rfl‚ü©
  isOpen_sUnion S := by
    intro hS
    choose! g h‚ÇÅ h‚ÇÇ using hS
    use ‚ãÉ‚ÇÄ (g '' S)
    constructor
    ¬∑ apply T_Y.isOpen_sUnion
      rintro _ ‚ü®U, hU, rfl‚ü©
      exact h‚ÇÅ U hU
    ¬∑ rw [preimage_sUnion, biUnion_image, sUnion_eq_biUnion]
      exact iUnion‚ÇÇ_congr h‚ÇÇ

example [hY : TopologicalSpace Y] (f : X ‚Üí Y) (U : Set X)
  : (hY.induced f).IsOpen U ‚Üî ‚àÉ (V : Set Y), hY.IsOpen V ‚àß f ‚Åª¬π' V = U
  := isOpen_induced_iff

-- Push and pull operations form a Galois connection.
--   f_* T_X ‚â§ T_Y ‚Üî T_X ‚â§ f^* T_Y
example (f : X ‚Üí Y) (T_X : TopologicalSpace X) (T_Y : TopologicalSpace Y) :
    TopologicalSpace.coinduced f T_X ‚â§ T_Y ‚Üî T_X ‚â§ TopologicalSpace.induced f T_Y :=
  coinduced_le_iff_le_induced

-- Given f : X ‚Üí Y and g : Y ‚Üí Z, (g ‚àò f)_* T_X = g_* (f_* T_X).
-- (pushing forward is covariant)
#check coinduced_compose

-- Given f : X ‚Üí Y and g : Y ‚Üí Z, (g ‚àò f)^* T_Z = f^* (g^* T_Z).
-- (pulling back is contravariant)
#check induced_compose

-- Order on topologies
-- Want:
--   f(T) = ùìù_T(x) is order preserving
--   i.e., ‚àÄ x ‚àà X, if T ‚â§ T' then ùìù_T(x) ‚â§ ùìù_T'(x)
--   i.e., every neighborhood of a point according to T'
--         is a neighborhood of that point according to T
--         but there may be more neighborhoods of the point according to T
--   Intuition: T' has a stricter requirement regarding neighborhoods of a point
-- Therefore:
--   T ‚â§ T' if any open V in T' is open in T
example {T T' : TopologicalSpace X} : T ‚â§ T' ‚Üî ‚àÄ s, T'.IsOpen s ‚Üí T.IsOpen s :=
  Iff.rfl

-- T ‚â§ T' iff for all X, ùìù_T(x) ‚â§ ùìù_T'(x)
-- reads as "T is finer than T'"
example {T T' : TopologicalSpace X} : T ‚â§ T' ‚Üî ‚àÄ x, @nhds X T x ‚â§ @nhds X T' x :=
  le_iff_nhds T T'

-- f is continuous wrt T_X and T_Y iff f_* T_X ‚â§ T_Y
-- Note: f_* T_X is the finest/"smallest"/"has the most sets" topology on Y making f continuous
example (T_X : TopologicalSpace X) (T_Y : TopologicalSpace Y) (f : X ‚Üí Y) :
    Continuous f ‚Üî TopologicalSpace.coinduced f T_X ‚â§ T_Y :=
  continuous_iff_coinduced_le

-- f is continuous wrt T_X and T_Y iff T_X ‚â§ f^* T_Y
-- f^* T_Y is the coarsest/"largest"/"has the fewest sets" topology on X making f continuous
-- (related to the Galois connection: f_* T_X ‚â§ T_Y ‚Üî T_X ‚â§ f^* T_Y)
example (T_X : TopologicalSpace X) (T_Y : TopologicalSpace Y) (f : X ‚Üí Y) :
    Continuous f ‚Üî T_X ‚â§ TopologicalSpace.induced f T_Y :=
    continuous_iff_coinduced_le.trans coinduced_le_iff_le_induced
    -- or, `continuous_iff_le_induced`

-- Universal property of the pushforward topology:
-- Given:
--   f : X ‚Üí Y, g : Y ‚Üí Z
--   topology T_X on X
-- Then:
--   for every topology T_Z on Z,
--   g is continuous wrt f_* T_X and T_Z iff
--   g ‚àò f is continuous wrt T_X and T_Z
-- Proof: g is continuous ‚Üî g_* (f_* T_X) ‚â§ T_Z ‚Üî (g ‚àò f)_* T_X ‚â§ T_Z ‚Üî g ‚àò f is continuous
example {Z : Type*} (f : X ‚Üí Y) (g : Y ‚Üí Z) (T_X : TopologicalSpace X) (T_Z : TopologicalSpace Z)
  : Continuous[T_X.coinduced f, T_Z] g ‚Üî Continuous[T_X, T_Z] (g ‚àò f) := by
  rw [continuous_iff_coinduced_le, coinduced_compose, continuous_iff_coinduced_le]
  -- or, `continuous_coinduced_dom`

-- Universal property of the pullback topology:
-- Given:
--   g : X ‚Üí Y, g : Y ‚Üí Z
--   topology T_Z on Z
-- Then:
--   for every topology T_X on X,
--   f is continuous wrt T_X and g^* T_Z iff
--   g ‚àò f is continuous wrt T_X and T_Z
-- Proof: f is continuous ‚Üî T_X ‚â§ f^*(g^* T_Z) ‚Üî T_X ‚â§ (g ‚àò f)^* T_Z ‚Üî g ‚àò f is continuous
example {Z : Type*} (f : X ‚Üí Y) (g : Y ‚Üí Z) (T_X : TopologicalSpace X) (T_Z : TopologicalSpace Z)
  : Continuous[T_X, T_Z.induced g] f ‚Üî Continuous[T_X, T_Z] (g ‚àò f) := by
  rw [continuous_iff_le_induced, induced_compose, continuous_iff_le_induced]
  -- or, `continuous_induced_rng`

-- Given a topological space (X, T) and an equivalence relation ~ on X,
-- the quotient space X / ~ is a topological space with topology f_* T,
-- where f : X ‚Üí X / ~ is the projection map.
-- Intuition: the topology on the quotient space is the finest topology
--            making the projection map continuous
instance QuotientTopologicalSpace (T : TopologicalSpace X) (S : Setoid X) :
    TopologicalSpace (Quotient S) := T.coinduced (Quotient.mk S)

example (T : TopologicalSpace X) (S : Setoid X) :
    QuotientTopologicalSpace T S = @instTopologicalSpaceQuotient X S T := rfl

-- Example:
--   X = ‚Ñù, T = standard topology on ‚Ñù
--   ‚àÄ x, y ‚àà X, x ~ y iff x - y ‚àà ‚Ñ§
--   ----------------------------------------------
--   quotient space ‚Ñù / ~
--   projection map f : ‚Ñù ‚Üí ‚Ñù / ~ (f(x) = fraction part of x)
--   quotient (topological) space (‚Ñù / ~, f_* T)

-- Define a relation on ‚Ñù
def r_intdiff : ‚Ñù ‚Üí ‚Ñù ‚Üí Prop := fun x x' => ‚àÉ z : ‚Ñ§, x - x' = z

def r_trivial : ‚Ñù ‚Üí ‚Ñù ‚Üí Prop := fun _ _ => True

def r_trivial2 : ‚Ñù ‚Üí ‚Ñù ‚Üí Prop := fun x y => x = y

-- Prove that the relation is an equivalence relation
instance eq_intdiff : Equivalence r_intdiff where
  refl x := by
    use 0
    rw [Int.cast_zero]
    exact sub_eq_zero_of_eq rfl
  symm := by
    intro x y
    rintro ‚ü®z, h‚ü©
    use -z
    rw [Int.cast_neg, ‚Üê h]
    exact (neg_sub x y).symm
  trans := by
    intro x y z
    rintro ‚ü®z‚ÇÅ, h‚ÇÅ‚ü© ‚ü®z‚ÇÇ, h‚ÇÇ‚ü©
    use z‚ÇÅ + z‚ÇÇ
    rw [Int.cast_add, ‚Üê h‚ÇÅ, ‚Üê h‚ÇÇ]
    exact (sub_add_sub_cancel x y z).symm

instance eq_trivial : Equivalence r_trivial where
  refl := by
    intro _
    trivial
  symm := by
    intro x y _
    trivial
  trans := by
    intro x y z _ _
    trivial

instance eq_trivial2 : Equivalence r_trivial2 where
  refl := by
    intro _
    trivial
  symm := by
    intro x y h
    exact h.symm
  trans := by
    intro x y z h‚ÇÅ h‚ÇÇ
    exact h‚ÇÅ.trans h‚ÇÇ

-- Define the bundle of equivalence relation
def setoid_‚Ñù_intdiff : Setoid ‚Ñù where
  iseqv := eq_intdiff

def setoid_‚Ñù_trivial : Setoid ‚Ñù where
  iseqv := eq_trivial

def setoid_‚Ñù_trivial2 : Setoid ‚Ñù where
  iseqv := eq_trivial2

-- Define the quotient space based on the equivalence relation
def quotient_‚Ñù_intdiff := Quotient setoid_‚Ñù_intdiff

def quotient_‚Ñù_trivial := Quotient setoid_‚Ñù_trivial

def quotient_‚Ñù_trivial2 := Quotient setoid_‚Ñù_trivial2

-- Define the projection map (not necessary)
def proj_‚Ñù_intdiff : ‚Ñù ‚Üí quotient_‚Ñù_intdiff := Quotient.mk setoid_‚Ñù_intdiff

def proj_‚Ñù_trivial : ‚Ñù ‚Üí quotient_‚Ñù_trivial := Quotient.mk setoid_‚Ñù_trivial

def proj_‚Ñù_trivial2 : ‚Ñù ‚Üí quotient_‚Ñù_trivial2 := Quotient.mk setoid_‚Ñù_trivial2

-- Prove that the equivalence relation defines
-- a topological space on the quotient space
instance T_quotient_‚Ñù_intdiff [T_‚Ñù : TopologicalSpace ‚Ñù]
  : TopologicalSpace quotient_‚Ñù_intdiff
  := QuotientTopologicalSpace T_‚Ñù setoid_‚Ñù_intdiff

instance T_quotient_‚Ñù_trivial [T_‚Ñù : TopologicalSpace ‚Ñù]
  : TopologicalSpace quotient_‚Ñù_trivial
  := QuotientTopologicalSpace T_‚Ñù setoid_‚Ñù_trivial

instance T_quotient_‚Ñù_trivial2 [T_‚Ñù : TopologicalSpace ‚Ñù]
  : TopologicalSpace quotient_‚Ñù_trivial2
  := QuotientTopologicalSpace T_‚Ñù setoid_‚Ñù_trivial2

-- Product topology
-- Given a family of topological spaces {(X·µ¢, T·µ¢) : i ‚àà Œπ}
-- where the index set Œπ is arbitrary, the product space ‚àè·µ¢ X·µ¢
-- is a topological space with topology ‚®Ö·µ¢ p·µ¢^* T·µ¢
-- where p·µ¢ : ‚àè·µ¢ X·µ¢ ‚Üí X·µ¢ is the projection map.
-- (infimum of the pullback topologies)
--
-- Motivation:
--   we want a topology such that
--   for any topological space (Z, T_Z) and
--       any function f : Z ‚Üí ‚àè·µ¢ X·µ¢
--   f is continuous wrt (Z, T_Z) and (‚àè·µ¢ X·µ¢, ‚®Ö·µ¢ p·µ¢^* T·µ¢)
--   iff ‚àÄ i ‚àà Œπ, p·µ¢ ‚àò f is continuous wrt (Z, T_Z) and (X·µ¢, T·µ¢)
example (Œπ : Type*) (X : Œπ ‚Üí Type*) (T_X : ‚àÄ i, TopologicalSpace (X i)) :
    (Pi.topologicalSpace : TopologicalSpace (‚àÄ i, X i)) =
      ‚®Ö i, TopologicalSpace.induced (fun x ‚Ü¶ x i) (T_X i) :=
  rfl

-- Proof:
--   ‚àÄ i ‚àà Œπ, (p·µ¢ ‚àò f) is continuous wrt (Z, T_Z) and (X·µ¢, T·µ¢)
--   ‚áî ‚àÄ i ‚àà Œπ, (p·µ¢ ‚àò f)_* T_Z ‚â§ T·µ¢
--   ‚áî ‚àÄ i ‚àà Œπ, p·µ¢_* (f_* T_Z) ‚â§ T·µ¢
--   ‚áî ‚àÄ i ‚àà Œπ, f_* T_Z ‚â§ p·µ¢^* T·µ¢
--   ‚áî f_* T_Z ‚â§ ‚®Ö·µ¢ p·µ¢^* T·µ¢
--   ‚áî f is continuous wrt (Z, T_Z) and (‚àè·µ¢ X·µ¢, ‚®Ö·µ¢ p·µ¢^* T·µ¢)
example {Z : Type*} {Œπ : Type*} (X : Œπ ‚Üí Type*) (f : Z ‚Üí Œ† i, X i) (T_Z : TopologicalSpace Z) (T_X : ‚àÄ i, TopologicalSpace (X i))
  : Continuous[T_Z, Pi.topologicalSpace] f ‚Üî ‚àÄ i, Continuous[T_Z, T_X i] ((fun x ‚Ü¶ x i) ‚àò f) :=
  -- continuous_pi_iff
  by
  rw [continuous_iff_coinduced_le]
  rw [Pi.topologicalSpace]
  rw [le_iInf_iff]
  simp_rw [‚Üê coinduced_le_iff_le_induced]
  simp_rw [coinduced_compose]
  simp_rw [‚Üê continuous_iff_coinduced_le]

example [TopologicalSpace X] [T2Space X] {u : ‚Ñï ‚Üí X} {a b : X} (ha : Tendsto u atTop (ùìù a))
    (hb : Tendsto u atTop (ùìù b)) : a = b :=
  tendsto_nhds_unique ha hb

example [TopologicalSpace X] [RegularSpace X] (a : X) :
    (ùìù a).HasBasis (fun s : Set X ‚Ü¶ s ‚àà ùìù a ‚àß IsClosed s) id :=
  closed_nhds_basis a

example [TopologicalSpace X] {x : X} :
    (ùìù x).HasBasis (fun t : Set X ‚Ü¶ t ‚àà ùìù x ‚àß IsOpen t) id :=
  nhds_basis_opens' x

theorem aux {X Y A : Type*} [TopologicalSpace X] {c : A ‚Üí X}
      {f : A ‚Üí Y} {x : X} {F : Filter Y}
      (h : Tendsto f (comap c (ùìù x)) F) {V' : Set Y} (V'_in : V' ‚àà F) :
    ‚àÉ V ‚àà ùìù x, IsOpen V ‚àß c ‚Åª¬π' V ‚äÜ f ‚Åª¬π' V' := by
  rcases h V'_in with ‚ü®U, hUinNx, hcinvUssfinvV'‚ü©
  rw [mem_nhds_iff] at hUinNx
  rcases hUinNx with ‚ü®V, hVssU, hopenV, hxinV‚ü©
  use V
  exact ‚ü®
    IsOpen.mem_nhds hopenV hxinV,
    hopenV,
    fun _ hxincinvV => hcinvUssfinvV' (hVssU hxincinvV),
  ‚ü©

example [TopologicalSpace X] [TopologicalSpace Y] [T3Space Y] {A : Set X}
    (hA : ‚àÄ x, x ‚àà closure A) {f : A ‚Üí Y} (f_cont : Continuous f)
    (hf : ‚àÄ x : X, ‚àÉ c : Y, Tendsto f (comap (‚Üë) (ùìù x)) (ùìù c)) :
    ‚àÉ œÜ : X ‚Üí Y, Continuous œÜ ‚àß ‚àÄ a : A, œÜ a = f a := by
  choose œÜ hœÜ using hf
  use œÜ
  constructor
  ¬∑ rw [continuous_iff_continuousAt]
    intro x
    suffices ‚àÄ V' ‚àà ùìù (œÜ x), IsClosed V' ‚Üí œÜ ‚Åª¬π' V' ‚àà ùìù x by
      rw [continuousAt_def]
      intro A hAinNœÜx
      rcases (closed_nhds_basis (œÜ x)).mem_iff.mp hAinNœÜx with ‚ü®V', ‚ü®hV'inNœÜx, hclosedV'‚ü©, hV'ssA‚ü©
      exact mem_of_superset (this V' hV'inNœÜx hclosedV') (preimage_mono hV'ssA)
    intro V' hV'inNœÜx hclosedV'
    rcases aux (hœÜ x) hV'inNœÜx with ‚ü®V, hVinNx, hopenV, hcinvVssfinvV'‚ü©
    apply mem_of_superset hVinNx
    intro y hyV
    have hVinNy: V ‚àà ùìù y := hopenV.mem_nhds hyV
    have := mem_closure_iff_comap_neBot.mp (hA y)
    apply hclosedV'.mem_of_tendsto (hœÜ y)
    exact mem_of_superset (preimage_mem_comap hVinNy) hcinvVssfinvV'
  ¬∑ intro a
    apply tendsto_nhds_unique _ f_cont.continuousAt
    rw [nhds_induced]
    exact hœÜ a

#check HasBasis.tendsto_right_iff

example [TopologicalSpace X] [FirstCountableTopology X]
      {s : Set X} {a : X} :
    a ‚àà closure s ‚Üî ‚àÉ u : ‚Ñï ‚Üí X, (‚àÄ n, u n ‚àà s) ‚àß Tendsto u atTop (ùìù a) :=
  mem_closure_iff_seq_limit

variable [TopologicalSpace X]

example {F : Filter X} {x : X} : ClusterPt x F ‚Üî NeBot (ùìù x ‚äì F) :=
  Iff.rfl

example {s : Set X} :
    IsCompact s ‚Üî ‚àÄ (F : Filter X) [NeBot F], F ‚â§ ùìü s ‚Üí ‚àÉ a ‚àà s, ClusterPt a F :=
  Iff.rfl

example [FirstCountableTopology X] {s : Set X} {u : ‚Ñï ‚Üí X} (hs : IsCompact s)
    (hu : ‚àÄ n, u n ‚àà s) : ‚àÉ a ‚àà s, ‚àÉ œÜ : ‚Ñï ‚Üí ‚Ñï, StrictMono œÜ ‚àß Tendsto (u ‚àò œÜ) atTop (ùìù a) :=
  hs.tendsto_subseq hu

variable [TopologicalSpace Y]

example {x : X} {F : Filter X} {G : Filter Y} (H : ClusterPt x F) {f : X ‚Üí Y}
    (hfx : ContinuousAt f x) (hf : Tendsto f F G) : ClusterPt (f x) G :=
  ClusterPt.map H hfx hf

example [TopologicalSpace Y] {f : X ‚Üí Y} (hf : Continuous f) {s : Set X} (hs : IsCompact s) :
    IsCompact (f '' s) := by
  intro F F_ne F_le
  have map_eq : map f (ùìü s ‚äì comap f F) = ùìü (f '' s) ‚äì F := by
    rw [Filter.push_pull]
    rw [map_principal]
  have Hne : (ùìü s ‚äì comap f F).NeBot := by
    apply NeBot.of_map
    rw [map_eq]
    rw [inf_of_le_right F_le]
    exact F_ne
  have Hle : ùìü s ‚äì comap f F ‚â§ ùìü s := inf_le_left
  rcases hs Hle with ‚ü®x, hxs, hclsptx‚ü©
  use f x
  constructor
  ¬∑ exact mem_image_of_mem f hxs
  ¬∑ apply hclsptx.map hf.continuousAt
    rw [Tendsto, map_eq]
    exact inf_le_right

example {Œπ : Type*} {s : Set X} (hs : IsCompact s) (U : Œπ ‚Üí Set X) (hUo : ‚àÄ i, IsOpen (U i))
    (hsU : s ‚äÜ ‚ãÉ i, U i) : ‚àÉ t : Finset Œπ, s ‚äÜ ‚ãÉ i ‚àà t, U i :=
  hs.elim_finite_subcover U hUo hsU
